<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>scheduler.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com</a>
<a name="ln3"> </a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;scheduler.h&quot;</a>
<a name="ln6">#include &quot;process.h&quot; </a>
<a name="ln7">#include &quot;lib.h&quot;</a>
<a name="ln8">#include &quot;queue.h&quot;</a>
<a name="ln9">#include &quot;pipes.h&quot;</a>
<a name="ln10">#include &quot;interrupts.h&quot; </a>
<a name="ln11">#include &quot;video_driver.h&quot;</a>
<a name="ln12">#include &quot;../include/time.h&quot;</a>
<a name="ln13">#include &lt;stddef.h&gt;</a>
<a name="ln14">#include &quot;synchro.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">extern void timer_tick();</a>
<a name="ln17"> </a>
<a name="ln18">#define SHELL_ADDRESS ((void *) 0x400000)     </a>
<a name="ln19"> </a>
<a name="ln20">static PCB *processes[MAX_PROCESSES];</a>
<a name="ln21">static queue_t ready_queue[PRIORITY_COUNT] = {0};</a>
<a name="ln22"> </a>
<a name="ln23">static pid_t current_pid = NO_PID;                </a>
<a name="ln24">static uint8_t process_count = 0;               </a>
<a name="ln25">static uint64_t total_cpu_ticks = 0;            </a>
<a name="ln26">static bool force_reschedule = false;           </a>
<a name="ln27">static bool scheduler_initialized = false;</a>
<a name="ln28">static pid_t foreground_process_pid = NO_PID;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">static PCB *pick_next_process(void);</a>
<a name="ln32">static void reparent_children_to_init(pid_t pid);</a>
<a name="ln33">static int init(int argc, char **argv);</a>
<a name="ln34">static int scheduler_add_init();</a>
<a name="ln35">static inline bool pid_is_valid(pid_t pid);</a>
<a name="ln36">static void cleanup_all_processes(void);</a>
<a name="ln37">static int create_shell();</a>
<a name="ln38">static inline bool pid_is_valid(pid_t pid) ;</a>
<a name="ln39">static void close_open_fds(PCB * p);</a>
<a name="ln40">static void apply_aging(void);</a>
<a name="ln41"> </a>
<a name="ln42">static inline bool pid_is_valid(pid_t pid) {</a>
<a name="ln43">    return pid &gt;= 0 &amp;&amp; pid &lt;= MAX_PID;</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">static void close_open_fds(PCB * p) {</a>
<a name="ln47">    while (!q_is_empty(p-&gt;open_fds)) {</a>
<a name="ln48">        int fd = q_poll(p-&gt;open_fds);</a>
<a name="ln49">        close_fd(fd);</a>
<a name="ln50">    }</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">// Proceso init: arranca la shell y se queda haciendo halt para no consumir CPU (actúa como proceso idle). Se lo elige siempre que no haya otro proceso para correr!!!!</a>
<a name="ln54">static int init(int argc, char **argv) {</a>
<a name="ln55">    if (create_shell() != 0) {</a>
<a name="ln56">        return -1;</a>
<a name="ln57">    }</a>
<a name="ln58">    scheduler_set_foreground_process(SHELL_PID);</a>
<a name="ln59">    while (1) {</a>
<a name="ln60">		_hlt();</a>
<a name="ln61">	}</a>
<a name="ln62">    return -1;</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">pid_t scheduler_get_foreground_pid(void) {</a>
<a name="ln67">    if (!scheduler_initialized) {</a>
<a name="ln68">        return NO_PID;</a>
<a name="ln69">    }</a>
<a name="ln70">    return foreground_process_pid;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">int scheduler_set_foreground_process(pid_t pid) {</a>
<a name="ln75">    if (!scheduler_initialized) {</a>
<a name="ln76">        return -1;</a>
<a name="ln77">    }</a>
<a name="ln78"> </a>
<a name="ln79">    // Permitimos limpiar el foreground pasando NO_PID</a>
<a name="ln80">    if (pid != NO_PID &amp;&amp; !pid_is_valid(pid)) {</a>
<a name="ln81">        return -1;</a>
<a name="ln82">    }</a>
<a name="ln83"> </a>
<a name="ln84">    foreground_process_pid = pid;</a>
<a name="ln85">    return 0;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">static int create_shell(){</a>
<a name="ln89">    PCB *pcb_shell = proc_create(SHELL_PID, (process_entry_t) SHELL_ADDRESS, 0, NULL, &quot;shell&quot;, false, NULL);</a>
<a name="ln90">    if (pcb_shell == NULL) {</a>
<a name="ln91">        return -1;</a>
<a name="ln92">    }</a>
<a name="ln93">    pcb_shell-&gt;priority = MAX_PRIORITY;</a>
<a name="ln94">    pcb_shell-&gt;effective_priority = MAX_PRIORITY;</a>
<a name="ln95">    pcb_shell-&gt;status = PS_READY; </a>
<a name="ln96">    pcb_shell-&gt;cpu_ticks = 0;</a>
<a name="ln97">    pcb_shell-&gt;last_tick = ticks_elapsed();</a>
<a name="ln98">    processes[SHELL_PID] = pcb_shell;</a>
<a name="ln99">    process_count++;</a>
<a name="ln100">    if (!q_add(ready_queue[pcb_shell-&gt;effective_priority], SHELL_PID)) {</a>
<a name="ln101">        processes[SHELL_PID] = NULL;</a>
<a name="ln102">        process_count--;</a>
<a name="ln103">        free_process_resources(pcb_shell);</a>
<a name="ln104">        return -1;</a>
<a name="ln105">    }</a>
<a name="ln106">    return 0;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">static int scheduler_add_init() {</a>
<a name="ln110">    if (process_count != 0) { // si no es el primer proceso en ser creado está mal</a>
<a name="ln111">        return -1;</a>
<a name="ln112">    }</a>
<a name="ln113"> </a>
<a name="ln114">    PCB *pcb_init = proc_create(INIT_PID, (process_entry_t) init, 0, NULL, &quot;init&quot;, false, NULL);</a>
<a name="ln115">    if (pcb_init == NULL) {</a>
<a name="ln116">        return -1;</a>
<a name="ln117">    }</a>
<a name="ln118"> </a>
<a name="ln119">    pcb_init-&gt;priority = MIN_PRIORITY; </a>
<a name="ln120">    pcb_init-&gt;effective_priority = MIN_PRIORITY;</a>
<a name="ln121">    pcb_init-&gt;status = PS_READY; </a>
<a name="ln122">    pcb_init-&gt;cpu_ticks = 0;</a>
<a name="ln123">    pcb_init-&gt;last_tick = 0; </a>
<a name="ln124"> </a>
<a name="ln125">    processes[INIT_PID] = pcb_init;</a>
<a name="ln126">    process_count++;</a>
<a name="ln127">    return 0;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">int init_scheduler(void) {</a>
<a name="ln131">    if (scheduler_initialized) { // para no crearlo más de una vez</a>
<a name="ln132">        return 0;</a>
<a name="ln133">    }</a>
<a name="ln134"> </a>
<a name="ln135">    // Inicializar array de procesos</a>
<a name="ln136">    for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln137">        processes[i] = NULL;</a>
<a name="ln138">    }</a>
<a name="ln139">    </a>
<a name="ln140">    // inicializamos las queues</a>
<a name="ln141">    for (int i = MAX_PRIORITY; i &lt;= MIN_PRIORITY; i++) {</a>
<a name="ln142">        ready_queue[i] = q_init();</a>
<a name="ln143">        if (ready_queue[i] == NULL) {</a>
<a name="ln144">            return -1;</a>
<a name="ln145">        }</a>
<a name="ln146">    }</a>
<a name="ln147">    </a>
<a name="ln148">   </a>
<a name="ln149">    process_count = 0;</a>
<a name="ln150">    total_cpu_ticks = 0;</a>
<a name="ln151">    force_reschedule = false;</a>
<a name="ln152">    current_pid = NO_PID; // NO le pongo INIT_PID porque el que lo tiene que elegir es el schedule la primera vez que se llama. </a>
<a name="ln153">    //Sino, la primera llamada a scheudule va a tratar a init como current y va a pisar su stack_pointer con prev_rsp</a>
<a name="ln154"> </a>
<a name="ln155">    if(scheduler_add_init() != 0) {</a>
<a name="ln156">        for (int i = MAX_PRIORITY; i &lt;= MIN_PRIORITY; i++) {</a>
<a name="ln157">        q_destroy(ready_queue[i]);</a>
<a name="ln158">    }</a>
<a name="ln159"> </a>
<a name="ln160">        return -1;</a>
<a name="ln161">    }</a>
<a name="ln162"> </a>
<a name="ln163">    scheduler_initialized = true;</a>
<a name="ln164">    return 0;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">void * schedule(void * prev_rsp) {</a>
<a name="ln169">    if (!scheduler_initialized) {</a>
<a name="ln170">        return prev_rsp;</a>
<a name="ln171">    }</a>
<a name="ln172"> </a>
<a name="ln173">    PCB *current = (pid_is_valid(current_pid)) ? processes[current_pid] : NULL;</a>
<a name="ln174"> </a>
<a name="ln175">    if (current) {</a>
<a name="ln176">        current-&gt;stack_pointer = prev_rsp; // actualiza el rsp del proceso que estuvo corriendo hasta ahora en su pcb</a>
<a name="ln177">        </a>
<a name="ln178">        current-&gt;cpu_ticks++; </a>
<a name="ln179">        total_cpu_ticks++;</a>
<a name="ln180"> </a>
<a name="ln181">        // Cuando un proceso deja de correr (por cualquier razón), vuelve a su prioridad base</a>
<a name="ln182">        // (pierde cualquier promoción temporal por aging)</a>
<a name="ln183">        current-&gt;effective_priority = current-&gt;priority;</a>
<a name="ln184"> </a>
<a name="ln185">        // Con quantum de 1 tick, siempre forzamos reschedule después de cada tick</a>
<a name="ln186">        // (a menos que el proceso ya no esté RUNNING por otra razón)</a>
<a name="ln187">        </a>
<a name="ln188">        if(current-&gt;status == PS_RUNNING){ </a>
<a name="ln189">            // Si el status es RUNNING, cambiar a READY</a>
<a name="ln190">            // Si fue bloqueado, terminado o matado, el status ya se cambió en otras funciones</a>
<a name="ln191">            current-&gt;status = PS_READY;</a>
<a name="ln192">        }</a>
<a name="ln193">        </a>
<a name="ln194">        if (current-&gt;status == PS_READY &amp;&amp; current-&gt;pid != INIT_PID) {</a>
<a name="ln195">            // Agregar a la cola correspondiente a su prioridad efectiva (que ya fue reseteada a priority)</a>
<a name="ln196">            queue_t target_queue = ready_queue[current-&gt;effective_priority];</a>
<a name="ln197">            if (!q_add(target_queue, current-&gt;pid)) {</a>
<a name="ln198">                current-&gt;status = PS_RUNNING;</a>
<a name="ln199">                force_reschedule = false;</a>
<a name="ln200">                return prev_rsp;</a>
<a name="ln201">            }</a>
<a name="ln202">        }</a>
<a name="ln203">    }</a>
<a name="ln204"> </a>
<a name="ln205">    // Aplicar aging cada N ticks</a>
<a name="ln206">    if (total_cpu_ticks % AGING_CHECK_INTERVAL == 0) {</a>
<a name="ln207">        apply_aging();</a>
<a name="ln208">    }</a>
<a name="ln209"> </a>
<a name="ln210">    // Si el proceso actual tiene que cambiar:</a>
<a name="ln211">    PCB *next = pick_next_process();</a>
<a name="ln212">    </a>
<a name="ln213">    // Si no hay otro proceso listo, usar el proceso init como fallback</a>
<a name="ln214">    if (!next) {</a>
<a name="ln215">        next = processes[INIT_PID];</a>
<a name="ln216">    }</a>
<a name="ln217"> </a>
<a name="ln218">    // Cuando un proceso va a correr:</a>
<a name="ln219">    // Actualizar su last_tick para el control de aging</a>
<a name="ln220">    next-&gt;last_tick = total_cpu_ticks;</a>
<a name="ln221"> </a>
<a name="ln222">    current_pid = next-&gt;pid;</a>
<a name="ln223">    next-&gt;status = PS_RUNNING;</a>
<a name="ln224">    force_reschedule = false;</a>
<a name="ln225">    return next-&gt;stack_pointer;</a>
<a name="ln226"> </a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229"> </a>
<a name="ln230">// Devuelve null si no hay proceso listo para correr en ninguna cola</a>
<a name="ln231">// Recorre las colas de mayor prioridad (0) a menor (PRIORITY_COUNT-1)</a>
<a name="ln232">static PCB *pick_next_process(void) {</a>
<a name="ln233">    if (!scheduler_initialized || process_count == 0) {</a>
<a name="ln234">        return NULL;</a>
<a name="ln235">    }</a>
<a name="ln236"> </a>
<a name="ln237">    // Recorrer las colas por orden de prioridad</a>
<a name="ln238">    for (int priority = MAX_PRIORITY; priority &lt;= MIN_PRIORITY; priority++) {</a>
<a name="ln239">        if (q_is_empty(ready_queue[priority])) {</a>
<a name="ln240">            continue;</a>
<a name="ln241">        }</a>
<a name="ln242">        </a>
<a name="ln243">        // Buscar un proceso válido en esta cola de prioridad</a>
<a name="ln244">        while (!q_is_empty(ready_queue[priority])) {</a>
<a name="ln245">            pid_t next_pid = (pid_t) q_poll(ready_queue[priority]);</a>
<a name="ln246">            if (!pid_is_valid(next_pid)) {</a>
<a name="ln247">                continue;</a>
<a name="ln248">            }</a>
<a name="ln249">            PCB *candidate = processes[next_pid];</a>
<a name="ln250">            if (candidate != NULL &amp;&amp; candidate-&gt;status == PS_READY) {</a>
<a name="ln251">                return candidate;</a>
<a name="ln252">            }</a>
<a name="ln253">            // Si el proceso ya no está listo, seguimos buscando en esta cola</a>
<a name="ln254">        }</a>
<a name="ln255">    }</a>
<a name="ln256"> </a>
<a name="ln257">    return NULL;</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260"> </a>
<a name="ln261">// Aplica aging: promueve procesos que llevan mucho tiempo sin correr</a>
<a name="ln262">static void apply_aging(void) {</a>
<a name="ln263">    // Recorrer desde MIN_PRIORITY hasta MAX_PRIORITY+1 (no promovemos desde MAX_PRIORITY)</a>
<a name="ln264">    for (int i = MIN_PRIORITY; i &gt; MAX_PRIORITY; i--) {</a>
<a name="ln265">        if (q_is_empty(ready_queue[i])) {</a>
<a name="ln266">            continue;</a>
<a name="ln267">        }</a>
<a name="ln268">        </a>
<a name="ln269">        q_to_begin(ready_queue[i]);</a>
<a name="ln270">        while (q_has_next(ready_queue[i])) {</a>
<a name="ln271">            pid_t pid = q_next(ready_queue[i]);</a>
<a name="ln272">            PCB *p = processes[pid];</a>
<a name="ln273">            </a>
<a name="ln274">            // Si el proceso no existe o no cumple el threshold, continuar</a>
<a name="ln275">            if (p == NULL) {</a>
<a name="ln276">                continue;</a>
<a name="ln277">            }</a>
<a name="ln278">            </a>
<a name="ln279">            // Verificar si hace mucho que no corre (comparar con total_cpu_ticks)</a>
<a name="ln280">            if (total_cpu_ticks - p-&gt;last_tick &gt;= AGING_THRESHOLD) {</a>
<a name="ln281">                // Promover: remover de esta cola y agregar a la de mayor prioridad</a>
<a name="ln282">                q_remove_current(ready_queue[i]);</a>
<a name="ln283">                p-&gt;effective_priority = i - 1;  // Subir un nivel de prioridad</a>
<a name="ln284">                p-&gt;last_tick = total_cpu_ticks; // Actualizar last_tick para evitar promociones repetidas</a>
<a name="ln285">                q_add(ready_queue[i - 1], pid);</a>
<a name="ln286">                </a>
<a name="ln287">            }</a>
<a name="ln288">        }</a>
<a name="ln289">    }</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292"> </a>
<a name="ln293">// Agrega el proceso al array de procesos y a la cola READY</a>
<a name="ln294">int scheduler_add_process(process_entry_t entry, int argc, const char **argv, const char *name, int fds[2]) {</a>
<a name="ln295">    if (!scheduler_initialized || process_count &gt;= MAX_PROCESSES) {</a>
<a name="ln296">        return -1;</a>
<a name="ln297">    }</a>
<a name="ln298"> </a>
<a name="ln299">    // Buscar primer PID libre</a>
<a name="ln300">    pid_t pid = NO_PID;</a>
<a name="ln301">    for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln302">        if (processes[i] == NULL) {</a>
<a name="ln303">            pid = i;</a>
<a name="ln304">            break;</a>
<a name="ln305">        }</a>
<a name="ln306">    }</a>
<a name="ln307">    if (!pid_is_valid(pid)) {</a>
<a name="ln308">        return -1;</a>
<a name="ln309">    }</a>
<a name="ln310"> </a>
<a name="ln311">    PCB *process = proc_create(pid, entry, argc, argv, name, true, fds);</a>
<a name="ln312">    if (process == NULL) {</a>
<a name="ln313">        return -1;</a>
<a name="ln314">    }</a>
<a name="ln315"> </a>
<a name="ln316">    // Inicializar campos relacionados con scheduling</a>
<a name="ln317">    process-&gt;priority = DEFAULT_PRIORITY; // Asignar prioridad por defecto</a>
<a name="ln318">    process-&gt;effective_priority = DEFAULT_PRIORITY; // Inicialmente igual a priority</a>
<a name="ln319">    process-&gt;status = PS_READY; </a>
<a name="ln320">    process-&gt;cpu_ticks = 0;</a>
<a name="ln321">    process-&gt;last_tick = total_cpu_ticks;</a>
<a name="ln322"> </a>
<a name="ln323"> </a>
<a name="ln324">    processes[pid] = process;</a>
<a name="ln325">    process_count++;</a>
<a name="ln326"> </a>
<a name="ln327">    if (!q_add(ready_queue[process-&gt;effective_priority], pid)) {</a>
<a name="ln328">        processes[pid] = NULL;</a>
<a name="ln329">        process_count--;</a>
<a name="ln330">        free_process_resources(process);</a>
<a name="ln331">        return -1;</a>
<a name="ln332">    }</a>
<a name="ln333"> </a>
<a name="ln334">    return pid;</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">int scheduler_remove_process(pid_t pid) {</a>
<a name="ln338">    if (!scheduler_initialized || !pid_is_valid(pid)) {</a>
<a name="ln339">        return -1;</a>
<a name="ln340">    }</a>
<a name="ln341"> </a>
<a name="ln342">    PCB *process = processes[pid];</a>
<a name="ln343">    if (!process) {</a>
<a name="ln344">        return -1;</a>
<a name="ln345">    }</a>
<a name="ln346"> </a>
<a name="ln347">    // Remover de la cola de procesos listos para correr</a>
<a name="ln348">    if (process-&gt;status == PS_READY || process-&gt;status == PS_RUNNING) {</a>
<a name="ln349">        // Buscar en la cola correspondiente a su prioridad efectiva</a>
<a name="ln350">        q_remove(ready_queue[process-&gt;effective_priority], process-&gt;pid);</a>
<a name="ln351">    }</a>
<a name="ln352"> </a>
<a name="ln353">    // Remover del array</a>
<a name="ln354">    processes[pid] = NULL;</a>
<a name="ln355">    process_count--;</a>
<a name="ln356"> </a>
<a name="ln357">    // Si estábamos ejecutando este proceso, forzar reschedule</a>
<a name="ln358">    if (current_pid == pid) {</a>
<a name="ln359">        current_pid = -1;</a>
<a name="ln360">        scheduler_force_reschedule(); </a>
<a name="ln361">    }</a>
<a name="ln362"> </a>
<a name="ln363">    // Liberar recursos del proceso</a>
<a name="ln364">    free_process_resources(process);</a>
<a name="ln365"> </a>
<a name="ln366">    return 0;</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">int scheduler_set_priority(pid_t pid, uint8_t new_priority) {</a>
<a name="ln370">   if (!scheduler_initialized || !pid_is_valid(pid) || </a>
<a name="ln371">        processes[pid] == NULL || </a>
<a name="ln372">        new_priority &lt; MAX_PRIORITY || new_priority &gt; MIN_PRIORITY) { // mas chico el numero, mayor la prioridad</a>
<a name="ln373">        return -1;</a>
<a name="ln374">    }</a>
<a name="ln375"> </a>
<a name="ln376">    PCB *process = processes[pid];</a>
<a name="ln377">    uint8_t old_priority = process-&gt;priority;</a>
<a name="ln378">    uint8_t old_effective_priority = process-&gt;effective_priority;</a>
<a name="ln379">    </a>
<a name="ln380">    // Si la prioridad no cambia, no hacer nada</a>
<a name="ln381">    if (old_priority == new_priority) {</a>
<a name="ln382">        return 0;</a>
<a name="ln383">    }</a>
<a name="ln384">    </a>
<a name="ln385">    // Si el proceso está READY, hay que moverlo de una cola a otra</a>
<a name="ln386">    if (process-&gt;status == PS_READY) { </a>
<a name="ln387">        // Remover de la cola actual (usa effective_priority porque ahí está realmente)</a>
<a name="ln388">        q_remove(ready_queue[old_effective_priority], pid);</a>
<a name="ln389">        </a>
<a name="ln390">        // Cambiar ambas prioridades</a>
<a name="ln391">        process-&gt;priority = new_priority;</a>
<a name="ln392">        process-&gt;effective_priority = new_priority;</a>
<a name="ln393">        </a>
<a name="ln394">        // Actualizar last_tick: el cambio manual de prioridad cuenta como &quot;atención&quot; del scheduler</a>
<a name="ln395">        process-&gt;last_tick = total_cpu_ticks;</a>
<a name="ln396">        </a>
<a name="ln397">        // Agregar a la nueva cola</a>
<a name="ln398">        if (!q_add(ready_queue[new_priority], pid)) {</a>
<a name="ln399">            // Si falla, volver a poner en la cola antigua</a>
<a name="ln400">            process-&gt;priority = old_priority;</a>
<a name="ln401">            process-&gt;effective_priority = old_effective_priority;</a>
<a name="ln402">            q_add(ready_queue[old_effective_priority], pid);</a>
<a name="ln403">            return -1;</a>
<a name="ln404">        }</a>
<a name="ln405">    } else {</a>
<a name="ln406">        // Si está RUNNING, BLOCKED o TERMINATED, solo cambiar la prioridad base</a>
<a name="ln407">        // effective_priority se reseteará cuando vuelva a correr</a>
<a name="ln408">        process-&gt;priority = new_priority;</a>
<a name="ln409">        process-&gt;effective_priority = new_priority;</a>
<a name="ln410">    }</a>
<a name="ln411">    </a>
<a name="ln412">    return 0;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">int scheduler_get_priority(pid_t pid) {</a>
<a name="ln416">    if (!scheduler_initialized || !pid_is_valid(pid) || processes[pid] == NULL) {</a>
<a name="ln417">        return -1;</a>
<a name="ln418">    }</a>
<a name="ln419">    PCB *process = processes[pid];</a>
<a name="ln420">    return process-&gt;priority;</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423">void scheduler_force_reschedule(void) {</a>
<a name="ln424">    if (scheduler_initialized) {</a>
<a name="ln425">        force_reschedule = true;</a>
<a name="ln426">        timer_tick();</a>
<a name="ln427">    }</a>
<a name="ln428"> </a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">int scheduler_get_current_pid(void) {</a>
<a name="ln432">    if (scheduler_initialized) {</a>
<a name="ln433">        return current_pid;</a>
<a name="ln434">    }</a>
<a name="ln435">    return -1;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438"> </a>
<a name="ln439">void scheduler_yield(void) {</a>
<a name="ln440">    scheduler_force_reschedule(); </a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">int scheduler_kill_process(pid_t pid) {</a>
<a name="ln444">    if(!scheduler_initialized) {</a>
<a name="ln445">        return -1; // Scheduler not initialized</a>
<a name="ln446">    }</a>
<a name="ln447">    </a>
<a name="ln448">    if (!pid_is_valid(pid)) {</a>
<a name="ln449">        return -2; // Invalid PID</a>
<a name="ln450">    }</a>
<a name="ln451">    </a>
<a name="ln452">    PCB *killed_process = processes[pid];</a>
<a name="ln453">    if (!killed_process) {</a>
<a name="ln454">        return -3; // No process found with this PID</a>
<a name="ln455">    }</a>
<a name="ln456"> </a>
<a name="ln457">    if (!killed_process-&gt;killable) {</a>
<a name="ln458">        return -4; // Process is protected (init or shell)</a>
<a name="ln459">    }</a>
<a name="ln460"> </a>
<a name="ln461">    reparent_children_to_init(killed_process-&gt;pid);</a>
<a name="ln462"> </a>
<a name="ln463">    remove_process_from_all_semaphore_queues(killed_process-&gt;pid);</a>
<a name="ln464"> </a>
<a name="ln465">    if (pid == foreground_process_pid) {</a>
<a name="ln466">        foreground_process_pid = SHELL_PID;</a>
<a name="ln467">        pipe_on_process_killed(killed_process-&gt;pid); // matamos el foreground group si estaba pipeado</a>
<a name="ln468">    }</a>
<a name="ln469"> </a>
<a name="ln470">    killed_process-&gt;status = PS_TERMINATED;</a>
<a name="ln471">    killed_process-&gt;return_value = KILLED_RET_VALUE;</a>
<a name="ln472">    </a>
<a name="ln473">    // cierra los fds abiertos</a>
<a name="ln474">    close_open_fds(killed_process);</a>
<a name="ln475"> </a>
<a name="ln476"> </a>
<a name="ln477">    if(killed_process-&gt;parent_pid == INIT_PID) {</a>
<a name="ln478">        scheduler_remove_process(killed_process-&gt;pid); </a>
<a name="ln479">    } else { // si el padre no es init, no vamos a eliminarlo porque su padre podria hacerle un wait</a>
<a name="ln480">        // Lo sacamos de la cola de procesos ready para que no vuelva a correr PERO NO  del array de procesos (para que el padre pueda acceder a su ret_value)</a>
<a name="ln481">        if (killed_process-&gt;status == PS_READY || killed_process-&gt;status == PS_RUNNING) {</a>
<a name="ln482">            q_remove(ready_queue[killed_process-&gt;effective_priority], killed_process-&gt;pid);</a>
<a name="ln483">        }</a>
<a name="ln484">        killed_process-&gt;status = PS_TERMINATED; // Le cambio el estado despues de hacer el dequeue o sino no va a entrar en la condición del if</a>
<a name="ln485">        killed_process-&gt;return_value = KILLED_RET_VALUE;</a>
<a name="ln486">        PCB* parent = processes[killed_process-&gt;parent_pid];</a>
<a name="ln487"> </a>
<a name="ln488">        if (parent != NULL &amp;&amp; parent-&gt;status == PS_BLOCKED &amp;&amp; parent-&gt;waiting_on == killed_process-&gt;pid) {</a>
<a name="ln489">            scheduler_unblock_process(parent-&gt;pid);</a>
<a name="ln490">        }</a>
<a name="ln491">    }</a>
<a name="ln492">    if(pid == current_pid){</a>
<a name="ln493">        scheduler_yield();</a>
<a name="ln494">    }</a>
<a name="ln495">    return 0;</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498"> </a>
<a name="ln499">// Llamar desde proc_block() en processes.c</a>
<a name="ln500">int scheduler_block_process(pid_t pid) {</a>
<a name="ln501">    if (!scheduler_initialized || !pid_is_valid(pid)) {</a>
<a name="ln502">        return -1;</a>
<a name="ln503">    }</a>
<a name="ln504">    </a>
<a name="ln505">    PCB *process = processes[pid];</a>
<a name="ln506">    if (process == NULL) {</a>
<a name="ln507">        return -1;</a>
<a name="ln508">    }</a>
<a name="ln509">    </a>
<a name="ln510">    // Remover de cola READY (si está ahí)</a>
<a name="ln511">    if (process-&gt;status == PS_READY || process-&gt;status == PS_RUNNING) {</a>
<a name="ln512">        q_remove(ready_queue[process-&gt;effective_priority], process-&gt;pid);</a>
<a name="ln513">    }</a>
<a name="ln514">    </a>
<a name="ln515">    process-&gt;status = PS_BLOCKED;</a>
<a name="ln516">    </a>
<a name="ln517">    // Si es el proceso actual, forzar reschedule</a>
<a name="ln518">    if (pid == current_pid) {</a>
<a name="ln519">        scheduler_force_reschedule();</a>
<a name="ln520">    }</a>
<a name="ln521">    </a>
<a name="ln522">    return 0;</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">int scheduler_unblock_process(pid_t pid) {</a>
<a name="ln527">    if (!scheduler_initialized || !pid_is_valid(pid)) {</a>
<a name="ln528">        return -1;</a>
<a name="ln529">    }</a>
<a name="ln530">    </a>
<a name="ln531">    PCB *process = processes[pid];</a>
<a name="ln532">    if (!process || process-&gt;status != PS_BLOCKED) {</a>
<a name="ln533">        return -1;</a>
<a name="ln534">    }</a>
<a name="ln535">    </a>
<a name="ln536">    process-&gt;status = PS_READY;</a>
<a name="ln537">    </a>
<a name="ln538">    // Al desbloquearse, el proceso vuelve a su prioridad base</a>
<a name="ln539">    // (por si fue promovido por aging mientras esperaba ser seleccionado, antes de bloquearse)</a>
<a name="ln540">    process-&gt;effective_priority = process-&gt;priority;</a>
<a name="ln541">    </a>
<a name="ln542">    // Actualizar last_tick: el tiempo bloqueado no cuenta para aging</a>
<a name="ln543">    // El proceso debe esperar en READY para acumular tiempo y ser promovido</a>
<a name="ln544">    process-&gt;last_tick = total_cpu_ticks;</a>
<a name="ln545">    </a>
<a name="ln546">    // Agregar a la cola correspondiente a su prioridad efectiva</a>
<a name="ln547">    if (!q_add(ready_queue[process-&gt;effective_priority], pid)) {</a>
<a name="ln548">        process-&gt;status = PS_BLOCKED;</a>
<a name="ln549">        return -1;</a>
<a name="ln550">    }</a>
<a name="ln551">    </a>
<a name="ln552">    return 0;</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">static void cleanup_all_processes(void) {</a>
<a name="ln556">    if (!scheduler_initialized) {</a>
<a name="ln557">        return;</a>
<a name="ln558">    }</a>
<a name="ln559"> </a>
<a name="ln560">    for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln561">        PCB *p = processes[i];</a>
<a name="ln562">        if (p) {</a>
<a name="ln563">            free_process_resources(p);</a>
<a name="ln564">            processes[i] = NULL;</a>
<a name="ln565">        }</a>
<a name="ln566">    }</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">void scheduler_destroy(void) {</a>
<a name="ln570">    if (!scheduler_initialized) {</a>
<a name="ln571">        return;</a>
<a name="ln572">    }</a>
<a name="ln573"> </a>
<a name="ln574">    // Limpiar todas las colas de prioridades liberando nodos</a>
<a name="ln575">    for (int i = MAX_PRIORITY; i &lt;= MIN_PRIORITY; i++) {</a>
<a name="ln576">        q_destroy(ready_queue[i]);</a>
<a name="ln577">        ready_queue[i] = NULL;</a>
<a name="ln578">    }</a>
<a name="ln579"> </a>
<a name="ln580">    cleanup_all_processes();</a>
<a name="ln581"> </a>
<a name="ln582">    process_count = 0;</a>
<a name="ln583">    total_cpu_ticks = 0;</a>
<a name="ln584">    force_reschedule = false;</a>
<a name="ln585">    current_pid = NO_PID;</a>
<a name="ln586">    scheduler_initialized = false;</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">// En scheduler.c</a>
<a name="ln590">PCB *scheduler_get_process(pid_t pid) {</a>
<a name="ln591">    if (!scheduler_initialized || !pid_is_valid(pid)) {</a>
<a name="ln592">        return NULL;</a>
<a name="ln593">    }</a>
<a name="ln594">    </a>
<a name="ln595">    return processes[pid];</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598"> </a>
<a name="ln599">int scheduler_get_processes(process_info_t *buffer, int max_count) {</a>
<a name="ln600">    if (!scheduler_initialized || buffer == NULL || max_count &lt;= 0) {</a>
<a name="ln601">        return -1;</a>
<a name="ln602">    }</a>
<a name="ln603"> </a>
<a name="ln604">    int count = 0;</a>
<a name="ln605">    for (int i = 0; i &lt; MAX_PROCESSES &amp;&amp; count &lt; max_count; i++) {</a>
<a name="ln606">        PCB *p = processes[i];</a>
<a name="ln607">        if (p) {</a>
<a name="ln608">            buffer[count].pid = p-&gt;pid;</a>
<a name="ln609">            strncpy(buffer[count].name, p-&gt;name, MAX_PROCESS_NAME_LENGTH);</a>
<a name="ln610">            buffer[count].status = p-&gt;status;</a>
<a name="ln611">            buffer[count].priority = p-&gt;priority;</a>
<a name="ln612">            buffer[count].parent_pid = p-&gt;parent_pid;</a>
<a name="ln613">            buffer[count].read_fd = p-&gt;read_fd;</a>
<a name="ln614">            buffer[count].write_fd = p-&gt;write_fd;</a>
<a name="ln615">            buffer[count].stack_base = (uint64_t)p-&gt;stack_base;</a>
<a name="ln616">            buffer[count].stack_pointer = (uint64_t)p-&gt;stack_pointer;</a>
<a name="ln617">            </a>
<a name="ln618">            count++;</a>
<a name="ln619">        }</a>
<a name="ln620">    }</a>
<a name="ln621"> </a>
<a name="ln622">    return count;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625"> </a>
<a name="ln626">void scheduler_exit_process(int64_t ret_value) {</a>
<a name="ln627">    if(!scheduler_initialized) {</a>
<a name="ln628">        return;</a>
<a name="ln629">    }</a>
<a name="ln630">    </a>
<a name="ln631">    PCB * current_process = processes[current_pid];</a>
<a name="ln632">    </a>
<a name="ln633">    reparent_children_to_init(current_process-&gt;pid);</a>
<a name="ln634"> </a>
<a name="ln635">    if (current_pid == foreground_process_pid) {</a>
<a name="ln636">        foreground_process_pid = SHELL_PID;</a>
<a name="ln637">    }</a>
<a name="ln638">    remove_process_from_all_semaphore_queues(current_process-&gt;pid);</a>
<a name="ln639">    </a>
<a name="ln640">    // limpia los fds abiertos</a>
<a name="ln641">    close_open_fds(current_process);</a>
<a name="ln642"> </a>
<a name="ln643">    if(current_process-&gt;parent_pid == INIT_PID) { // si el padre es init, no hace falta mantener su pcb para guardarnos ret_value pues nadie le va a hacer waitpid</a>
<a name="ln644">        scheduler_remove_process(current_process-&gt;pid); </a>
<a name="ln645">    } else{ // si el padre no es init, no vamos a eliminarlo porque su padre podria hacerle un wait</a>
<a name="ln646">        // Lo sacamos de la cola de procesos ready para que no vuelva a correr PERO NO  del array de procesos (para que el padre pueda acceder a su ret_value)</a>
<a name="ln647">        if (current_process-&gt;status == PS_READY || current_process-&gt;status == PS_RUNNING) {</a>
<a name="ln648">            q_remove(ready_queue[current_process-&gt;effective_priority], current_process-&gt;pid);</a>
<a name="ln649">        }</a>
<a name="ln650">        current_process-&gt;status = PS_TERMINATED; // Le cambio el estado despues de hacer el dequeue o sino no va a entrar en la condición del if</a>
<a name="ln651">        current_process-&gt;return_value = ret_value;</a>
<a name="ln652">        PCB* parent = processes[current_process-&gt;parent_pid];</a>
<a name="ln653"> </a>
<a name="ln654">        // Si el padre estaba bloqueado haciendo waitpid, lo desbloqueamos</a>
<a name="ln655">        if (parent-&gt;status == PS_BLOCKED &amp;&amp; parent-&gt;waiting_on == current_process-&gt;pid) {</a>
<a name="ln656">            scheduler_unblock_process(parent-&gt;pid);</a>
<a name="ln657">        }</a>
<a name="ln658">    </a>
<a name="ln659">    }</a>
<a name="ln660">    scheduler_yield();</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663"> </a>
<a name="ln664">// Bloquea al proceso actual hasta que el hijo indicado termine. Devuelve el status del hijo si ya terminó o 0.</a>
<a name="ln665">int scheduler_waitpid(pid_t child_pid) {</a>
<a name="ln666">    if (!scheduler_initialized || !pid_is_valid(child_pid) || </a>
<a name="ln667">        processes[child_pid] == NULL || </a>
<a name="ln668">        processes[child_pid]-&gt;parent_pid != current_pid) {</a>
<a name="ln669">        return -1;</a>
<a name="ln670">    }</a>
<a name="ln671">    </a>
<a name="ln672">    // Si el proceso hijo no termino, bloqueamos el proceso actual hasta que termine</a>
<a name="ln673">    if (processes[child_pid]-&gt;status != PS_TERMINATED) {</a>
<a name="ln674">        processes[current_pid]-&gt;waiting_on = child_pid;</a>
<a name="ln675">        scheduler_block_process(current_pid);</a>
<a name="ln676">    }</a>
<a name="ln677"> </a>
<a name="ln678">    // Llega acá cuando el hijo terminó y lo desbloqueo o si el hijo ya había terminado</a>
<a name="ln679">    </a>
<a name="ln680">    processes[current_pid]-&gt;waiting_on = NO_PID;</a>
<a name="ln681">    int ret_value = processes[child_pid]-&gt;return_value;</a>
<a name="ln682">    scheduler_remove_process(child_pid);</a>
<a name="ln683"> </a>
<a name="ln684">    return ret_value;</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687">int adopt_init_as_parent(pid_t pid) {</a>
<a name="ln688">    if(!scheduler_initialized || !pid_is_valid(pid)) {</a>
<a name="ln689">        return -1;</a>
<a name="ln690">    }</a>
<a name="ln691">    PCB *init_process = processes[INIT_PID];</a>
<a name="ln692">    if (init_process == NULL) {</a>
<a name="ln693">        return -1;</a>
<a name="ln694">    }</a>
<a name="ln695"> </a>
<a name="ln696">    PCB *orphan_process = processes[pid];</a>
<a name="ln697">    if (orphan_process == NULL) {</a>
<a name="ln698">        return -1;</a>
<a name="ln699">    }</a>
<a name="ln700"> </a>
<a name="ln701">    orphan_process-&gt;parent_pid = INIT_PID;</a>
<a name="ln702">    return 0;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">static void reparent_children_to_init(pid_t pid) {</a>
<a name="ln706">    if(!scheduler_initialized || !pid_is_valid(pid)) {</a>
<a name="ln707">        return;</a>
<a name="ln708">    }</a>
<a name="ln709">	for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln710">		if (processes[i] != NULL &amp;&amp;</a>
<a name="ln711">			processes[i]-&gt;parent_pid == pid) {</a>
<a name="ln712">            // Asignar el proceso huérfano al init</a>
<a name="ln713">            if(processes[i]-&gt;status == PS_TERMINATED){</a>
<a name="ln714">                // Si el hijo ya estaba terminado, lo removemos directamente</a>
<a name="ln715">                scheduler_remove_process(processes[i]-&gt;pid);</a>
<a name="ln716">            } else{</a>
<a name="ln717">                processes[i]-&gt;parent_pid = INIT_PID;</a>
<a name="ln718">            }   </a>
<a name="ln719">        }</a>
<a name="ln720">	}</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723"> </a>
<a name="ln724">// Mata el proceso que está en foreground. Devuelve 0 en éxito, -1 en error.</a>
<a name="ln725">int scheduler_kill_foreground_process(void) {</a>
<a name="ln726">    if (!scheduler_initialized) {</a>
<a name="ln727">        return -1;</a>
<a name="ln728">    }</a>
<a name="ln729"> </a>
<a name="ln730">    // Si no hay proceso en foreground, retornar error</a>
<a name="ln731">    if (foreground_process_pid == NO_PID) {</a>
<a name="ln732">        return -1;</a>
<a name="ln733">    }</a>
<a name="ln734"> </a>
<a name="ln735">    int result = scheduler_kill_process(foreground_process_pid);</a>
<a name="ln736">    // Después de matar el proceso en foreground, establecer la shell como proceso en foreground</a>
<a name="ln737">    foreground_process_pid = SHELL_PID;</a>
<a name="ln738">    </a>
<a name="ln739">    return result;</a>
<a name="ln740">}</a>
</code></pre>
<div class="balloon" rel="324"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'pid' index could reach -1.</p></div>
<div class="balloon" rel="328"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'pid' index could reach -1.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
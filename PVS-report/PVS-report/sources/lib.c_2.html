<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>lib.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;stdint.h&gt;</a>
<a name="ln5"> </a>
<a name="ln6">void * memset(void * destination, int32_t c, uint64_t length){</a>
<a name="ln7">	uint8_t chr = (uint8_t)c;</a>
<a name="ln8">	char * dst = (char*)destination;</a>
<a name="ln9"> </a>
<a name="ln10">	while(length--)</a>
<a name="ln11">		dst[length] = chr;</a>
<a name="ln12"> </a>
<a name="ln13">	return destination;</a>
<a name="ln14">}</a>
<a name="ln15"> </a>
<a name="ln16">void * memcpy(void * destination, const void * source, uint64_t length){</a>
<a name="ln17">	/*</a>
<a name="ln18">	* memcpy does not support overlapping buffers, so always do it</a>
<a name="ln19">	* forwards. (Don't change this without adjusting memmove.)</a>
<a name="ln20">	*</a>
<a name="ln21">	* For speedy copying, optimize the common case where both pointers</a>
<a name="ln22">	* and the length are word-aligned, and copy word-at-a-time instead</a>
<a name="ln23">	* of byte-at-a-time. Otherwise, copy by bytes.</a>
<a name="ln24">	*</a>
<a name="ln25">	* The alignment logic below should be portable. We rely on</a>
<a name="ln26">	* the compiler to be reasonably intelligent about optimizing</a>
<a name="ln27">	* the divides and modulos out. Fortunately, it is.</a>
<a name="ln28">	*/</a>
<a name="ln29">	uint64_t i = 0;</a>
<a name="ln30">	uint8_t * d = (uint8_t*)destination;</a>
<a name="ln31">	const uint8_t * s = (const uint8_t*)source;</a>
<a name="ln32"> </a>
<a name="ln33">	// Copy byte by byte until aligned to 8 bytes</a>
<a name="ln34">	while (i &lt; length &amp;&amp; ((uint64_t)(d + i) % sizeof(uint64_t) != 0 || (uint64_t)(s + i) % sizeof(uint64_t) != 0)){</a>
<a name="ln35">		d[i] = s[i];</a>
<a name="ln36">		i++;</a>
<a name="ln37">	}</a>
<a name="ln38"> </a>
<a name="ln39">	// Copy 8 bytes at a time when aligned</a>
<a name="ln40">	uint64_t *d64 = (uint64_t *)(d + i);</a>
<a name="ln41">	const uint64_t *s64 = (const uint64_t *)(s + i);</a>
<a name="ln42">	uint64_t remaining = length - i;</a>
<a name="ln43">	uint64_t aligned_count = remaining / sizeof(uint64_t);</a>
<a name="ln44"> </a>
<a name="ln45">	for (uint64_t j = 0; j &lt; aligned_count; j++){</a>
<a name="ln46">		d64[j] = s64[j];</a>
<a name="ln47">	}</a>
<a name="ln48"> </a>
<a name="ln49">	i += aligned_count * sizeof(uint64_t);</a>
<a name="ln50"> </a>
<a name="ln51">	// Copy remaining bytes</a>
<a name="ln52">	while (i &lt; length){</a>
<a name="ln53">		d[i] = s[i];</a>
<a name="ln54">		i++;</a>
<a name="ln55">	}</a>
<a name="ln56"> </a>
<a name="ln57">	return destination;</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">void * memset64(void * destination, uint64_t pattern, uint64_t length){</a>
<a name="ln61">	uint8_t *d = (uint8_t *)destination;</a>
<a name="ln62">	uint64_t i = 0;</a>
<a name="ln63"> </a>
<a name="ln64">	// Write bytes until destination is 8-byte aligned or until no bytes left</a>
<a name="ln65">	while (i &lt; length &amp;&amp; ((uint64_t)(d + i) % sizeof(uint64_t) != 0)) {</a>
<a name="ln66">		d[i++] = (uint8_t)pattern; // Use LSB of pattern for tail bytes</a>
<a name="ln67">	}</a>
<a name="ln68"> </a>
<a name="ln69">	// Now destination is aligned or no more bytes left</a>
<a name="ln70">	uint64_t remaining = length - i;</a>
<a name="ln71">	uint64_t words = remaining / sizeof(uint64_t);</a>
<a name="ln72"> </a>
<a name="ln73">	uint64_t *d64 = (uint64_t *)(d + i);</a>
<a name="ln74">	for (uint64_t j = 0; j &lt; words; j++) {</a>
<a name="ln75">		d64[j] = pattern;</a>
<a name="ln76">	}</a>
<a name="ln77"> </a>
<a name="ln78">	i += words * sizeof(uint64_t);</a>
<a name="ln79"> </a>
<a name="ln80">	// Trailing bytes</a>
<a name="ln81">	while (i &lt; length) {</a>
<a name="ln82">		d[i++] = (uint8_t)pattern;</a>
<a name="ln83">	}</a>
<a name="ln84"> </a>
<a name="ln85">	return destination;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">// Copia hasta n caracteres de src a dst</a>
<a name="ln89">char *strncpy(char *dst, const char *src, int n) {</a>
<a name="ln90">    char *ret = dst;</a>
<a name="ln91">    while (n &gt; 0 &amp;&amp; *src) {</a>
<a name="ln92">        *dst++ = *src++;</a>
<a name="ln93">        n--;</a>
<a name="ln94">    }</a>
<a name="ln95">    while (n &gt; 0) {</a>
<a name="ln96">        *dst++ = '\0'; // Rellenamos con '\0' si src termin√≥ antes</a>
<a name="ln97">        n--;</a>
<a name="ln98">    }</a>
<a name="ln99">    return ret;</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">int strcmp(const char *s1, const char *s2) {</a>
<a name="ln103">	while (*s1 &amp;&amp; (*s1 == *s2)) {</a>
<a name="ln104">		s1++;</a>
<a name="ln105">		s2++;</a>
<a name="ln106">	}</a>
<a name="ln107">	return *(const unsigned char *) s1 - *(const unsigned char *) s2;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">char strlen(const char *str) {</a>
<a name="ln111">	int res = 0;</a>
<a name="ln112">	while(*str++) {</a>
<a name="ln113">		res++;</a>
<a name="ln114">	}</a>
<a name="ln115">	return res;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">uint64_t decimal_to_str(uint64_t value, char * buffer) {</a>
<a name="ln119">	char *p = buffer;</a>
<a name="ln120">	char *p1, *p2;</a>
<a name="ln121">	uint64_t digits = 0;</a>
<a name="ln122"> </a>
<a name="ln123">	//Calculate characters for each digit</a>
<a name="ln124">	do{</a>
<a name="ln125">		uint32_t remainder = value % 10;</a>
<a name="ln126">		*p++ = (remainder &lt; 10) ? remainder + '0' : remainder + 'A' - 10;</a>
<a name="ln127">		digits++;</a>
<a name="ln128">	}</a>
<a name="ln129">	while (value /= 10);</a>
<a name="ln130"> </a>
<a name="ln131">	*p = 0;</a>
<a name="ln132"> </a>
<a name="ln133">	p1 = buffer;</a>
<a name="ln134">	p2 = p - 1;</a>
<a name="ln135">	while (p1 &lt; p2){</a>
<a name="ln136">		char tmp = *p1;</a>
<a name="ln137">		*p1 = *p2;</a>
<a name="ln138">		*p2 = tmp;</a>
<a name="ln139">		p1++;</a>
<a name="ln140">		p2--;</a>
<a name="ln141">	}</a>
<a name="ln142">	return digits;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">int strcat(char *dest, const char *src) {</a>
<a name="ln146">	int i = strlen(dest);</a>
<a name="ln147">	while (*src) {</a>
<a name="ln148">		dest[i++] = *src++;</a>
<a name="ln149">	}</a>
<a name="ln150">	dest[i] = '\0';</a>
<a name="ln151">	return i;</a>
<a name="ln152">}</a>
</code></pre>
<div class="balloon" rel="126"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'remainder &lt; 10' is always true.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
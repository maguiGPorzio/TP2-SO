<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bmfs.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/* BareMetal File System Utility */</a>
<a name="ln2">/* Written by Ian Seyler of Return Infinity */</a>
<a name="ln3"> </a>
<a name="ln4">/* Global includes */</a>
<a name="ln5">#include &lt;stdio.h&gt;</a>
<a name="ln6">#include &lt;stdlib.h&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8">#include &lt;strings.h&gt;</a>
<a name="ln9">#include &lt;ctype.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">/* Global defines */</a>
<a name="ln12">struct BMFSEntry</a>
<a name="ln13">{</a>
<a name="ln14">	char FileName[32];</a>
<a name="ln15">	unsigned long long StartingBlock;</a>
<a name="ln16">	unsigned long long ReservedBlocks;</a>
<a name="ln17">	unsigned long long FileSize;</a>
<a name="ln18">	unsigned long long Unused;</a>
<a name="ln19">};</a>
<a name="ln20"> </a>
<a name="ln21">/* Global constants */</a>
<a name="ln22">// Min disk size is 6MiB (three blocks of 2MiB each.)</a>
<a name="ln23">const unsigned long long minimumDiskSize = (6 * 1024 * 1024);</a>
<a name="ln24"> </a>
<a name="ln25">/* Global variables */</a>
<a name="ln26">FILE *file, *disk;</a>
<a name="ln27">unsigned int filesize, disksize;</a>
<a name="ln28">char tempfilename[32], tempstring[32];</a>
<a name="ln29">char *filename, *diskname, *command;</a>
<a name="ln30">char fs_tag[] = &quot;BMFS&quot;;</a>
<a name="ln31">char s_list[] = &quot;list&quot;;</a>
<a name="ln32">char s_format[] = &quot;format&quot;;</a>
<a name="ln33">char s_initialize[] = &quot;initialize&quot;;</a>
<a name="ln34">char s_create[] = &quot;create&quot;;</a>
<a name="ln35">char s_read[] = &quot;read&quot;;</a>
<a name="ln36">char s_write[] = &quot;write&quot;;</a>
<a name="ln37">char s_delete[] = &quot;delete&quot;;</a>
<a name="ln38">struct BMFSEntry entry;</a>
<a name="ln39">void *pentry = &amp;entry;</a>
<a name="ln40">char *BlockMap;</a>
<a name="ln41">char *FileBlocks;</a>
<a name="ln42">char Directory[4096];</a>
<a name="ln43">char DiskInfo[512];</a>
<a name="ln44"> </a>
<a name="ln45">/* Built-in functions */</a>
<a name="ln46">int findfile(char *filename, struct BMFSEntry *fileentry, int *entrynumber);</a>
<a name="ln47">void list();</a>
<a name="ln48">void format();</a>
<a name="ln49">int initialize(char *diskname, char *size, char *mbr, char *boot, char *kernel);</a>
<a name="ln50">void create(char *filename, unsigned long long maxsize);</a>
<a name="ln51">void read(char *filename);</a>
<a name="ln52">void write(char *filename);</a>
<a name="ln53">void delete(char *filename);</a>
<a name="ln54"> </a>
<a name="ln55">/* Program code */</a>
<a name="ln56">int main(int argc, char *argv[])</a>
<a name="ln57">{</a>
<a name="ln58">	/* Parse arguments */</a>
<a name="ln59">	if (argc &lt; 3)</a>
<a name="ln60">	{</a>
<a name="ln61">		printf(&quot;BareMetal File System Utility v1.0 (2013 04 10)\n&quot;);</a>
<a name="ln62">		printf(&quot;Written by Ian Seyler @ Return Infinity (ian.seyler@returninfinity.com)\n\n&quot;);</a>
<a name="ln63">		printf(&quot;Usage: %s disk function file\n&quot;, argv[0]);</a>
<a name="ln64">		printf(&quot;Disk: the name of the disk file\n&quot;);</a>
<a name="ln65">		printf(&quot;Function: list, read, write, create, delete, format, initialize\n&quot;);</a>
<a name="ln66">		printf(&quot;File: (if applicable)\n&quot;);</a>
<a name="ln67">		exit(0);</a>
<a name="ln68">	}</a>
<a name="ln69"> </a>
<a name="ln70">	diskname = argv[1];</a>
<a name="ln71">	command = argv[2];</a>
<a name="ln72">	filename = argv[3];</a>
<a name="ln73"> </a>
<a name="ln74">	if (strcasecmp(s_initialize, command) == 0)</a>
<a name="ln75">	{</a>
<a name="ln76">		if (argc &gt;= 4)</a>
<a name="ln77">		{</a>
<a name="ln78">			char *size = argv[3];  // Required</a>
<a name="ln79">			char *mbr = (argc &gt; 4 ? argv[4] : NULL);    // Opt.</a>
<a name="ln80">			char *boot = (argc &gt; 5 ? argv[5] : NULL);   // Opt.</a>
<a name="ln81">			char *kernel = (argc &gt; 6 ? argv[6] : NULL); // Opt.</a>
<a name="ln82">			int ret = initialize(diskname, size, mbr, boot, kernel);</a>
<a name="ln83">			exit(ret);</a>
<a name="ln84">		}</a>
<a name="ln85">		else</a>
<a name="ln86">		{</a>
<a name="ln87">			printf(&quot;Usage: %s disk %s &quot;, argv[0], command);</a>
<a name="ln88">			printf(&quot;size [mbr_file] &quot;);</a>
<a name="ln89">			printf(&quot;[bootloader_file] [kernel_file]\n&quot;);</a>
<a name="ln90">			exit(1);</a>
<a name="ln91">		}</a>
<a name="ln92">	}</a>
<a name="ln93"> </a>
<a name="ln94">	if ((disk = fopen(diskname, &quot;r+b&quot;)) == NULL)	// Open for read/write in binary mode</a>
<a name="ln95">	{</a>
<a name="ln96">		printf(&quot;Error: Unable to open disk '%s'\n&quot;, diskname);</a>
<a name="ln97">		exit(0);</a>
<a name="ln98">	}</a>
<a name="ln99">	else	// Opened ok, is it a valid BMFS disk?</a>
<a name="ln100">	{</a>
<a name="ln101">		fseek(disk, 0, SEEK_END);</a>
<a name="ln102">		disksize = ftell(disk) / 1048576;			// Disk size in MiB</a>
<a name="ln103">		fseek(disk, 1024, SEEK_SET);				// Seek 1KiB in for disk information</a>
<a name="ln104">		fread(DiskInfo, 512, 1, disk);				// Read 512 bytes to the DiskInfo buffer</a>
<a name="ln105">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln106">		fread(Directory, 4096, 1, disk);			// Read 4096 bytes to the Directory buffer</a>
<a name="ln107">		rewind(disk);</a>
<a name="ln108">		</a>
<a name="ln109">		if (strcasecmp(DiskInfo, fs_tag) != 0)		// Is it a BMFS formatted disk?</a>
<a name="ln110">		{</a>
<a name="ln111">			if (strcasecmp(s_format, command) == 0)</a>
<a name="ln112">			{</a>
<a name="ln113">				format();</a>
<a name="ln114">			}</a>
<a name="ln115">			else</a>
<a name="ln116">			{</a>
<a name="ln117">				printf(&quot;Error: Not a valid BMFS drive (Disk is not BMFS formatted).\n&quot;);</a>
<a name="ln118">			}</a>
<a name="ln119">			fclose(disk);</a>
<a name="ln120">			return 0;</a>
<a name="ln121">		}</a>
<a name="ln122">	}</a>
<a name="ln123"> </a>
<a name="ln124">	if (strcasecmp(s_list, command) == 0)</a>
<a name="ln125">	{</a>
<a name="ln126">		list();</a>
<a name="ln127">	}</a>
<a name="ln128">	else if (strcasecmp(s_format, command) == 0)</a>
<a name="ln129">	{</a>
<a name="ln130">		if (argc &gt; 3)</a>
<a name="ln131">		{</a>
<a name="ln132">			if (strcasecmp(argv[3], &quot;/FORCE&quot;) == 0)</a>
<a name="ln133">			{</a>
<a name="ln134">				format();</a>
<a name="ln135">			}</a>
<a name="ln136">			else</a>
<a name="ln137">			{</a>
<a name="ln138">				printf(&quot;Format aborted!\n&quot;);</a>
<a name="ln139">			}</a>
<a name="ln140">		}</a>
<a name="ln141">		else	</a>
<a name="ln142">		{</a>
<a name="ln143">			printf(&quot;Format aborted!\n&quot;);</a>
<a name="ln144">		}</a>
<a name="ln145">	}</a>
<a name="ln146">	else if (strcasecmp(s_create, command) == 0)</a>
<a name="ln147">	{</a>
<a name="ln148">		if (filename == NULL)</a>
<a name="ln149">		{</a>
<a name="ln150">			printf(&quot;Error: File name not specified.\n&quot;);</a>
<a name="ln151">		}</a>
<a name="ln152">		else</a>
<a name="ln153">		{</a>
<a name="ln154">			if (argc &gt; 4)</a>
<a name="ln155">			{</a>
<a name="ln156">				int filesize = atoi(argv[4]);</a>
<a name="ln157">				if (filesize &gt;= 1)</a>
<a name="ln158">				{</a>
<a name="ln159">					create(filename, filesize);</a>
<a name="ln160">				}</a>
<a name="ln161">				else</a>
<a name="ln162">				{</a>
<a name="ln163">			  		printf(&quot;Error: Invalid file size.\n&quot;);</a>
<a name="ln164">				}</a>
<a name="ln165">			}</a>
<a name="ln166">			else</a>
<a name="ln167">			{</a>
<a name="ln168">				printf(&quot;Maximum file size in MiB: &quot;);</a>
<a name="ln169">				fgets(tempstring, 32, stdin);			// Get up to 32 chars from the keyboard</a>
<a name="ln170">				filesize = atoi(tempstring);</a>
<a name="ln171">				if (filesize &gt;= 1)</a>
<a name="ln172">					create(filename, filesize);</a>
<a name="ln173">				else</a>
<a name="ln174">					printf(&quot;Error: Invalid file size.\n&quot;);</a>
<a name="ln175">			}</a>
<a name="ln176">		}</a>
<a name="ln177">	}</a>
<a name="ln178">	else if (strcasecmp(s_read, command) == 0)</a>
<a name="ln179">	{</a>
<a name="ln180">		read(filename);</a>
<a name="ln181">	}</a>
<a name="ln182">	else if (strcasecmp(s_write, command) == 0)</a>
<a name="ln183">	{</a>
<a name="ln184">		write(filename);</a>
<a name="ln185">	}</a>
<a name="ln186">	else if (strcasecmp(s_delete, command) == 0)</a>
<a name="ln187">	{</a>
<a name="ln188">		delete(filename);</a>
<a name="ln189">	}</a>
<a name="ln190">	else</a>
<a name="ln191">	{</a>
<a name="ln192">		printf(&quot;Unknown command\n&quot;);</a>
<a name="ln193">	}</a>
<a name="ln194">	if (disk != NULL)</a>
<a name="ln195">	{</a>
<a name="ln196">		fclose( disk );</a>
<a name="ln197">		disk = NULL;</a>
<a name="ln198">	}</a>
<a name="ln199">	return 0;</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203">int findfile(char *filename, struct BMFSEntry *fileentry, int *entrynumber)</a>
<a name="ln204">{</a>
<a name="ln205">	int tint;</a>
<a name="ln206"> </a>
<a name="ln207">	for (tint = 0; tint &lt; 64; tint++)</a>
<a name="ln208">	{</a>
<a name="ln209">		memcpy(pentry, Directory+(tint*64), 64);</a>
<a name="ln210">		if (entry.FileName[0] == 0x00)				// End of directory</a>
<a name="ln211">		{</a>
<a name="ln212">			tint = 64;</a>
<a name="ln213">		}</a>
<a name="ln214">		else if (entry.FileName[0] == 0x01)			// Emtpy entry</a>
<a name="ln215">		{</a>
<a name="ln216">			// Ignore</a>
<a name="ln217">		}</a>
<a name="ln218">		else										// Valid entry</a>
<a name="ln219">		{</a>
<a name="ln220">			if (strcmp(filename, entry.FileName) == 0)</a>
<a name="ln221">			{</a>
<a name="ln222">				memcpy(fileentry, pentry, 64);</a>
<a name="ln223">				*entrynumber = tint;</a>
<a name="ln224">				return 1;</a>
<a name="ln225">			}</a>
<a name="ln226">		}	</a>
<a name="ln227">	}</a>
<a name="ln228">	return 0;</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231"> </a>
<a name="ln232">void list()</a>
<a name="ln233">{</a>
<a name="ln234">	int tint;</a>
<a name="ln235"> </a>
<a name="ln236">	printf(&quot;%s\nDisk Size: %d MiB\n&quot;, diskname, disksize);</a>
<a name="ln237">	printf(&quot;Name                            |            Size (B)|      Reserved (MiB)\n&quot;);</a>
<a name="ln238">	printf(&quot;==========================================================================\n&quot;);</a>
<a name="ln239">	for (tint = 0; tint &lt; 64; tint++)			// Max 64 entries</a>
<a name="ln240">	{</a>
<a name="ln241">		memcpy(pentry, Directory+(tint*64), 64);</a>
<a name="ln242">		if (entry.FileName[0] == 0x00)				// End of directory, bail out</a>
<a name="ln243">		{</a>
<a name="ln244">			tint = 64;</a>
<a name="ln245">		}</a>
<a name="ln246">		else if (entry.FileName[0] == 0x01)			// Emtpy entry</a>
<a name="ln247">		{</a>
<a name="ln248">			// Ignore</a>
<a name="ln249">		}</a>
<a name="ln250">		else										// Valid entry</a>
<a name="ln251">		{</a>
<a name="ln252">			printf(&quot;%-32s %20lld %20lld\n&quot;, entry.FileName, entry.FileSize, (entry.ReservedBlocks*2));</a>
<a name="ln253">		}</a>
<a name="ln254">	}</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257"> </a>
<a name="ln258">void format()</a>
<a name="ln259">{</a>
<a name="ln260">	memset(DiskInfo, 0, 512);</a>
<a name="ln261">	memset(Directory, 0, 4096);</a>
<a name="ln262">	memcpy(DiskInfo, fs_tag, 4);				// Add the 'BMFS' tag</a>
<a name="ln263">	fseek(disk, 1024, SEEK_SET);				// Seek 1KiB in for disk information</a>
<a name="ln264">	fwrite(DiskInfo, 512, 1, disk);			// Write 512 bytes for the DiskInfo</a>
<a name="ln265">	fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln266">	fwrite(Directory, 4096, 1, disk);		// Write 4096 bytes for the Directory</a>
<a name="ln267">	printf(&quot;Format complete.\n&quot;);</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270"> </a>
<a name="ln271">int initialize(char *diskname, char *size, char *mbr, char *boot, char *kernel)</a>
<a name="ln272">{</a>
<a name="ln273">	unsigned long long diskSize = 0;</a>
<a name="ln274">	unsigned long long writeSize = 0;</a>
<a name="ln275">	const char *bootFileType = NULL;</a>
<a name="ln276">	size_t bufferSize = 50 * 1024;</a>
<a name="ln277">	char * buffer = NULL;</a>
<a name="ln278">	FILE *mbrFile = NULL;</a>
<a name="ln279">	FILE *bootFile = NULL;</a>
<a name="ln280">	FILE *kernelFile = NULL;</a>
<a name="ln281">	int diskSizeFactor = 0;</a>
<a name="ln282">	size_t chunkSize = 0;</a>
<a name="ln283">	int ret = 0;</a>
<a name="ln284">	size_t i;</a>
<a name="ln285"> </a>
<a name="ln286">	// Determine how the second file will be described in output messages.</a>
<a name="ln287">	// If a kernel file is specified too, then assume the second file is the</a>
<a name="ln288">	// boot loader.  If no kernel file is specified, assume the boot loader</a>
<a name="ln289">	// and kernel are combined into one system file.</a>
<a name="ln290">	if (boot != NULL)</a>
<a name="ln291">	{</a>
<a name="ln292">		bootFileType = &quot;boot loader&quot;;</a>
<a name="ln293">		if (kernel == NULL)</a>
<a name="ln294">		{</a>
<a name="ln295">			bootFileType = &quot;system&quot;;</a>
<a name="ln296">		}</a>
<a name="ln297">	}</a>
<a name="ln298"> </a>
<a name="ln299">	// Validate the disk size string and convert it to an integer value.</a>
<a name="ln300">	for (i = 0; size[i] != '\0' &amp;&amp; ret == 0; ++i)</a>
<a name="ln301">	{</a>
<a name="ln302">		char ch = size[i];</a>
<a name="ln303">		if (isdigit(ch))</a>
<a name="ln304">		{</a>
<a name="ln305">			unsigned int n = ch - '0';</a>
<a name="ln306">			if (diskSize * 10 &gt; diskSize ) // Make sure we don't overflow</a>
<a name="ln307">			{</a>
<a name="ln308">				diskSize *= 10;</a>
<a name="ln309">				diskSize += n;</a>
<a name="ln310">			}</a>
<a name="ln311">			else if (diskSize == 0) // First loop iteration</a>
<a name="ln312">			{</a>
<a name="ln313">				diskSize += n;</a>
<a name="ln314">			}</a>
<a name="ln315">			else</a>
<a name="ln316">			{</a>
<a name="ln317">				printf(&quot;Error: Disk size is too large\n&quot;);</a>
<a name="ln318">				ret = 1;</a>
<a name="ln319">			}</a>
<a name="ln320">		}</a>
<a name="ln321">		else if (i == 0) // No digits specified</a>
<a name="ln322">		{</a>
<a name="ln323">			printf(&quot;Error: A numeric disk size must be specified\n&quot;);</a>
<a name="ln324">			ret = 1;</a>
<a name="ln325">		}</a>
<a name="ln326">		else</a>
<a name="ln327">		{</a>
<a name="ln328">			switch (toupper(ch))</a>
<a name="ln329">			{</a>
<a name="ln330">					case 'K':</a>
<a name="ln331">						diskSizeFactor = 1;</a>
<a name="ln332">						break;</a>
<a name="ln333">					case 'M':</a>
<a name="ln334">						diskSizeFactor = 2;</a>
<a name="ln335">						break;</a>
<a name="ln336">					case 'G':</a>
<a name="ln337">						diskSizeFactor = 3;</a>
<a name="ln338">						break;</a>
<a name="ln339">					case 'T':</a>
<a name="ln340">						diskSizeFactor = 4;</a>
<a name="ln341">						break;</a>
<a name="ln342">					case 'P':</a>
<a name="ln343">						diskSizeFactor = 5;</a>
<a name="ln344">						break;</a>
<a name="ln345">					default:</a>
<a name="ln346">						printf(&quot;Error: Invalid disk size string: '%s'\n&quot;, size);</a>
<a name="ln347">						ret = 1;</a>
<a name="ln348">						break;</a>
<a name="ln349">			}</a>
<a name="ln350"> </a>
<a name="ln351">			// If this character is a valid unit indicator, but is not at the</a>
<a name="ln352">			// end of the string, then the string is invalid.</a>
<a name="ln353">			if (ret == 0 &amp;&amp; size[i+1] != '\0')</a>
<a name="ln354">			{</a>
<a name="ln355">				printf(&quot;Error: Invalid disk size string: '%s'\n&quot;, size);</a>
<a name="ln356">				ret = 1;</a>
<a name="ln357">			}</a>
<a name="ln358">		}</a>
<a name="ln359">	}</a>
<a name="ln360"> </a>
<a name="ln361">	// Adjust the disk size if a unit indicator was given.  Note that an</a>
<a name="ln362">	// input of something like &quot;0&quot; or &quot;0K&quot; will get past the checks above.</a>
<a name="ln363">	if (ret == 0 &amp;&amp; diskSize &gt; 0 &amp;&amp; diskSizeFactor &gt; 0)</a>
<a name="ln364">	{</a>
<a name="ln365">		while (diskSizeFactor--)</a>
<a name="ln366">		{</a>
<a name="ln367">			if (diskSize * 1024 &gt; diskSize ) // Make sure we don't overflow</a>
<a name="ln368">			{</a>
<a name="ln369">				diskSize *= 1024;</a>
<a name="ln370">			}</a>
<a name="ln371">			else</a>
<a name="ln372">			{</a>
<a name="ln373">				printf(&quot;Error: Disk size is too large\n&quot;);</a>
<a name="ln374">				ret = 1;</a>
<a name="ln375">			}</a>
<a name="ln376">		}</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	// Make sure the disk size is large enough.</a>
<a name="ln380">	if (ret == 0)</a>
<a name="ln381">	{</a>
<a name="ln382">		if (diskSize &lt; minimumDiskSize)</a>
<a name="ln383">		{</a>
<a name="ln384">			printf( &quot;Error: Disk size must be at least %llu bytes (%lluMiB)\n&quot;, minimumDiskSize, minimumDiskSize / (1024*1024));</a>
<a name="ln385">			ret = 1;</a>
<a name="ln386">		}</a>
<a name="ln387">	}</a>
<a name="ln388"> </a>
<a name="ln389">	// Open the Master boot Record file for reading.</a>
<a name="ln390">	if (ret == 0 &amp;&amp; mbr != NULL)</a>
<a name="ln391">	{</a>
<a name="ln392">		mbrFile = fopen(mbr, &quot;rb&quot;);</a>
<a name="ln393">		if (mbrFile == NULL )</a>
<a name="ln394">		{</a>
<a name="ln395">			printf(&quot;Error: Unable to open MBR file '%s'\n&quot;, mbr);</a>
<a name="ln396">			ret = 1;</a>
<a name="ln397">		}</a>
<a name="ln398">	}</a>
<a name="ln399"> </a>
<a name="ln400">	// Open the boot loader file for reading.</a>
<a name="ln401">	if (ret == 0 &amp;&amp; boot != NULL)</a>
<a name="ln402">	{</a>
<a name="ln403">		bootFile = fopen(boot, &quot;rb&quot;);</a>
<a name="ln404">		if (bootFile == NULL )</a>
<a name="ln405">		{</a>
<a name="ln406">			printf(&quot;Error: Unable to open %s file '%s'\n&quot;, bootFileType, boot);</a>
<a name="ln407">			ret = 1;</a>
<a name="ln408">		}</a>
<a name="ln409">	}</a>
<a name="ln410"> </a>
<a name="ln411">	// Open the kernel file for reading.</a>
<a name="ln412">	if (ret == 0 &amp;&amp; kernel != NULL)</a>
<a name="ln413">	{</a>
<a name="ln414">		kernelFile = fopen(kernel, &quot;rb&quot;);</a>
<a name="ln415">		if (kernelFile == NULL )</a>
<a name="ln416">		{</a>
<a name="ln417">			printf(&quot;Error: Unable to open kernel file '%s'\n&quot;, kernel);</a>
<a name="ln418">			ret = 1;</a>
<a name="ln419">		}</a>
<a name="ln420">	}</a>
<a name="ln421"> </a>
<a name="ln422">	// Allocate buffer to use for filling the disk image with zeros.</a>
<a name="ln423">	if (ret == 0)</a>
<a name="ln424">	{</a>
<a name="ln425">		buffer = (char *) malloc(bufferSize);</a>
<a name="ln426">		if (buffer == NULL)</a>
<a name="ln427">		{</a>
<a name="ln428">			printf(&quot;Error: Failed to allocate buffer\n&quot;);</a>
<a name="ln429">			ret = 1;</a>
<a name="ln430">		}</a>
<a name="ln431">	}</a>
<a name="ln432"> </a>
<a name="ln433">	// Open the disk image file for writing.  This will truncate the disk file</a>
<a name="ln434">	// if it already exists, so we should do this only after we're ready to</a>
<a name="ln435">	// actually write to the file.</a>
<a name="ln436">	if (ret == 0)</a>
<a name="ln437">	{</a>
<a name="ln438">		disk = fopen(diskname, &quot;wb&quot;);</a>
<a name="ln439">		if (disk == NULL)</a>
<a name="ln440">		{</a>
<a name="ln441">			printf(&quot;Error: Unable to open disk '%s'\n&quot;, diskname);</a>
<a name="ln442">			ret = 1;</a>
<a name="ln443">		}</a>
<a name="ln444">	}</a>
<a name="ln445"> </a>
<a name="ln446">	// Fill the disk image with zeros.</a>
<a name="ln447">	if (ret == 0)</a>
<a name="ln448">	{</a>
<a name="ln449">		double percent;</a>
<a name="ln450">		memset(buffer, 0, bufferSize);</a>
<a name="ln451">		writeSize = 0;</a>
<a name="ln452">		while (writeSize &lt; diskSize)</a>
<a name="ln453">		{</a>
<a name="ln454">			percent = writeSize;</a>
<a name="ln455">			percent /= diskSize;</a>
<a name="ln456">			percent *= 100;</a>
<a name="ln457">			printf(&quot;Formatting disk: %llu of %llu bytes (%.0f%%)...\r&quot;, writeSize, diskSize, percent);</a>
<a name="ln458">			chunkSize = bufferSize;</a>
<a name="ln459">			if (chunkSize &gt; diskSize - writeSize)</a>
<a name="ln460">			{</a>
<a name="ln461">				chunkSize = diskSize - writeSize;</a>
<a name="ln462">			}</a>
<a name="ln463">			if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln464">			{</a>
<a name="ln465">				printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln466">				ret = 1;</a>
<a name="ln467">				break;</a>
<a name="ln468">			}</a>
<a name="ln469">			writeSize += chunkSize;</a>
<a name="ln470">		}</a>
<a name="ln471">		if (ret == 0)</a>
<a name="ln472">		{</a>
<a name="ln473">			printf(&quot;Formatting disk: %llu of %llu bytes (100%%)%9s\n&quot;, writeSize, diskSize, &quot;&quot;);</a>
<a name="ln474">		}</a>
<a name="ln475">	}</a>
<a name="ln476"> </a>
<a name="ln477">	// Format the disk.</a>
<a name="ln478">	if (ret == 0)</a>
<a name="ln479">	{</a>
<a name="ln480">		rewind(disk);</a>
<a name="ln481">		format();</a>
<a name="ln482">	}</a>
<a name="ln483"> </a>
<a name="ln484">	// Write the master boot record if it was specified by the caller.</a>
<a name="ln485">	if (ret == 0 &amp;&amp; mbrFile !=NULL)</a>
<a name="ln486">	{</a>
<a name="ln487">		printf(&quot;Writing master boot record.\n&quot;);</a>
<a name="ln488">		fseek(disk, 0, SEEK_SET);</a>
<a name="ln489">		if (fread(buffer, 512, 1, mbrFile) == 1)</a>
<a name="ln490">		{</a>
<a name="ln491">			if (fwrite(buffer, 512, 1, disk) != 1)</a>
<a name="ln492">			{</a>
<a name="ln493">				printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln494">				ret = 1;</a>
<a name="ln495">			}</a>
<a name="ln496">		}</a>
<a name="ln497">		else</a>
<a name="ln498">		{</a>
<a name="ln499">			printf(&quot;Error: Failed to read file '%s'\n&quot;, mbr);</a>
<a name="ln500">			ret = 1;</a>
<a name="ln501">		}</a>
<a name="ln502">	}</a>
<a name="ln503"> </a>
<a name="ln504">	// Write the boot loader if it was specified by the caller.</a>
<a name="ln505">	if (ret == 0 &amp;&amp; bootFile !=NULL)</a>
<a name="ln506">	{</a>
<a name="ln507">		printf(&quot;Writing %s file.\n&quot;, bootFileType);</a>
<a name="ln508">		fseek(disk, 8192, SEEK_SET);</a>
<a name="ln509">		for (;;)</a>
<a name="ln510">		{</a>
<a name="ln511">			chunkSize = fread( buffer, 1, bufferSize, bootFile);</a>
<a name="ln512">			if (chunkSize &gt; 0)</a>
<a name="ln513">			{</a>
<a name="ln514">				if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln515">				{</a>
<a name="ln516">					printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln517">					ret = 1;</a>
<a name="ln518">				}</a>
<a name="ln519">			}</a>
<a name="ln520">			else</a>
<a name="ln521">			{</a>
<a name="ln522">				if (ferror(disk))</a>
<a name="ln523">				{</a>
<a name="ln524">					printf(&quot;Error: Failed to read file '%s'\n&quot;, boot);</a>
<a name="ln525">					ret = 1;</a>
<a name="ln526">				}</a>
<a name="ln527">				break;</a>
<a name="ln528">			}</a>
<a name="ln529">		}</a>
<a name="ln530">	}</a>
<a name="ln531"> </a>
<a name="ln532">	// Write the kernel if it was specified by the caller. The kernel must</a>
<a name="ln533">	// immediately follow the boot loader on disk (i.e. no seek needed.)</a>
<a name="ln534">	if (ret == 0 &amp;&amp; kernelFile !=NULL)</a>
<a name="ln535">	{</a>
<a name="ln536">		printf(&quot;Writing kernel.\n&quot;);</a>
<a name="ln537">		for (;;)</a>
<a name="ln538">		{</a>
<a name="ln539">			chunkSize = fread( buffer, 1, bufferSize, kernelFile);</a>
<a name="ln540">			if (chunkSize &gt; 0)</a>
<a name="ln541">			{</a>
<a name="ln542">				if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln543">				{</a>
<a name="ln544">					printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln545">					ret = 1;</a>
<a name="ln546">				}</a>
<a name="ln547">			}</a>
<a name="ln548">			else</a>
<a name="ln549">			{</a>
<a name="ln550">				if (ferror(disk))</a>
<a name="ln551">				{</a>
<a name="ln552">					printf(&quot;Error: Failed to read file '%s'\n&quot;, kernel);</a>
<a name="ln553">					ret = 1;</a>
<a name="ln554">				}</a>
<a name="ln555">				break;</a>
<a name="ln556">			}</a>
<a name="ln557">		}</a>
<a name="ln558">	}</a>
<a name="ln559"> </a>
<a name="ln560">	// Close any files that were opened.</a>
<a name="ln561">	if (mbrFile != NULL)</a>
<a name="ln562">	{</a>
<a name="ln563">		fclose(mbrFile);</a>
<a name="ln564">	}</a>
<a name="ln565">	if (bootFile != NULL)</a>
<a name="ln566">	{</a>
<a name="ln567">		fclose(bootFile);</a>
<a name="ln568">	}</a>
<a name="ln569">	if (kernelFile != NULL)</a>
<a name="ln570">	{</a>
<a name="ln571">		fclose(kernelFile);</a>
<a name="ln572">	}</a>
<a name="ln573">	if (disk != NULL)</a>
<a name="ln574">	{</a>
<a name="ln575">		fclose(disk);</a>
<a name="ln576">		disk = NULL;</a>
<a name="ln577">	}</a>
<a name="ln578"> </a>
<a name="ln579">	// Free the buffer if it was allocated.</a>
<a name="ln580">	if (buffer != NULL)</a>
<a name="ln581">	{</a>
<a name="ln582">		free(buffer);</a>
<a name="ln583">	}</a>
<a name="ln584"> </a>
<a name="ln585">	if (ret == 0)</a>
<a name="ln586">	{</a>
<a name="ln587">		printf(&quot;Disk initialization complete.\n&quot;);</a>
<a name="ln588">	}</a>
<a name="ln589"> </a>
<a name="ln590">	return ret;</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593"> </a>
<a name="ln594">// helper function for qsort, sorts by StartingBlock field</a>
<a name="ln595">static int StartingBlockCmp(const void *pa, const void *pb)</a>
<a name="ln596">{</a>
<a name="ln597">	struct BMFSEntry *ea = (struct BMFSEntry *)pa;</a>
<a name="ln598">	struct BMFSEntry *eb = (struct BMFSEntry *)pb;</a>
<a name="ln599">	// empty records go to the end</a>
<a name="ln600">	if (ea-&gt;FileName[0] == 0x01)</a>
<a name="ln601">		return 1;</a>
<a name="ln602">	if (eb-&gt;FileName[0] == 0x01)</a>
<a name="ln603">		return -1;</a>
<a name="ln604">	// compare non-empty records by their starting blocks number</a>
<a name="ln605">	return (ea-&gt;StartingBlock - eb-&gt;StartingBlock);</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">void create(char *filename, unsigned long long maxsize)</a>
<a name="ln609">{</a>
<a name="ln610">	struct BMFSEntry tempentry;</a>
<a name="ln611">	int slot;</a>
<a name="ln612">	</a>
<a name="ln613">	if (maxsize % 2 != 0)</a>
<a name="ln614">		maxsize++;</a>
<a name="ln615"> </a>
<a name="ln616">	if (findfile(filename, &amp;tempentry, &amp;slot) == 0)</a>
<a name="ln617">	{</a>
<a name="ln618">		unsigned long long blocks_requested = maxsize / 2; // how many blocks to allocate</a>
<a name="ln619">		unsigned long long num_blocks = disksize / 2; // number of blocks in the disk</a>
<a name="ln620">		char dir_copy[4096]; // copy of directory</a>
<a name="ln621">		int num_used_entries = 0; // how many entries of Directory are either used or deleted</a>
<a name="ln622">		int first_free_entry = -1; // where to put new entry</a>
<a name="ln623">		int tint;</a>
<a name="ln624">		struct BMFSEntry *pEntry;</a>
<a name="ln625">		unsigned long long new_file_start = 0;</a>
<a name="ln626">		unsigned long long prev_file_end = 1;</a>
<a name="ln627"> </a>
<a name="ln628">		printf(&quot;Creating new file...\n&quot;);</a>
<a name="ln629"> </a>
<a name="ln630">		// Make a copy of Directory to play with</a>
<a name="ln631">		memcpy(dir_copy, Directory, 4096);</a>
<a name="ln632"> </a>
<a name="ln633">		// Calculate number of files</a>
<a name="ln634">		for (tint = 0; tint &lt; 64; tint++) </a>
<a name="ln635">		{</a>
<a name="ln636">			pEntry = (struct BMFSEntry *)(dir_copy + tint * 64); // points to the current directory entry</a>
<a name="ln637">			if (pEntry-&gt;FileName[0] == 0x00) // end of directory</a>
<a name="ln638">			{</a>
<a name="ln639">				num_used_entries = tint;</a>
<a name="ln640">				if (first_free_entry == -1)</a>
<a name="ln641">					first_free_entry = tint; // there were no unused entires before, will use this one</a>
<a name="ln642">				break;</a>
<a name="ln643">			}</a>
<a name="ln644">			else if (pEntry-&gt;FileName[0] == 0x01) // unused entry</a>
<a name="ln645">			{</a>
<a name="ln646">				if (first_free_entry == -1)</a>
<a name="ln647">					first_free_entry = tint; // will use it for our new file</a>
<a name="ln648">			}</a>
<a name="ln649">		}</a>
<a name="ln650"> </a>
<a name="ln651">		if (first_free_entry == -1)</a>
<a name="ln652">		{</a>
<a name="ln653">			printf(&quot;Cannot create file: no free directory entries.\n&quot;);</a>
<a name="ln654">			return;</a>
<a name="ln655">		}</a>
<a name="ln656"> </a>
<a name="ln657">		// Find an area with enough free blocks</a>
<a name="ln658">		// Sort our copy of the directory by starting block number</a>
<a name="ln659">		qsort(dir_copy, num_used_entries, 64, StartingBlockCmp);</a>
<a name="ln660"> </a>
<a name="ln661">		for (tint = 0; tint &lt; num_used_entries + 1; tint++)</a>
<a name="ln662">		{</a>
<a name="ln663">			// on each iteration of this loop we'll see if a new file can fit</a>
<a name="ln664">			// between the end of the previous file (initially == 1) </a>
<a name="ln665">			// and the beginning of the current file (or the last data block if there are no more files).</a>
<a name="ln666"> </a>
<a name="ln667">			unsigned long long this_file_start;</a>
<a name="ln668">			pEntry = (struct BMFSEntry *)(dir_copy + tint * 64); // points to the current directory entry</a>
<a name="ln669"> </a>
<a name="ln670">			if (tint == num_used_entries || pEntry-&gt;FileName[0] == 0x01) </a>
<a name="ln671">				this_file_start = num_blocks - 1; // index of the last block</a>
<a name="ln672">			else</a>
<a name="ln673">				this_file_start = pEntry-&gt;StartingBlock;</a>
<a name="ln674"> </a>
<a name="ln675">			if (this_file_start - prev_file_end &gt;= blocks_requested) </a>
<a name="ln676">			{ // fits here</a>
<a name="ln677">				new_file_start = prev_file_end;</a>
<a name="ln678">				break;</a>
<a name="ln679">			}</a>
<a name="ln680"> </a>
<a name="ln681">			if (tint &lt; num_used_entries)</a>
<a name="ln682">				prev_file_end = pEntry-&gt;StartingBlock + pEntry-&gt;ReservedBlocks;</a>
<a name="ln683">		}</a>
<a name="ln684"> </a>
<a name="ln685">		if (new_file_start == 0) </a>
<a name="ln686">		{</a>
<a name="ln687">			printf(&quot;Cannot create file of size %lld MiB.\n&quot;, maxsize);</a>
<a name="ln688">			return;</a>
<a name="ln689">		}</a>
<a name="ln690"> </a>
<a name="ln691">		// Add file record to Directory</a>
<a name="ln692">		pEntry = (struct BMFSEntry *)(Directory + first_free_entry * 64);</a>
<a name="ln693">		pEntry-&gt;StartingBlock = new_file_start;</a>
<a name="ln694">		pEntry-&gt;ReservedBlocks = blocks_requested;</a>
<a name="ln695">		pEntry-&gt;FileSize = 0;</a>
<a name="ln696">		strcpy(pEntry-&gt;FileName, filename);</a>
<a name="ln697"> </a>
<a name="ln698">		if (first_free_entry == num_used_entries &amp;&amp; num_used_entries + 1 &lt; 64)</a>
<a name="ln699">		{</a>
<a name="ln700">			// here we used the record that was marked with 0x00, </a>
<a name="ln701">			// so make sure to mark the next record with 0x00 if it exists</a>
<a name="ln702">			pEntry = (struct BMFSEntry *)(Directory + (num_used_entries + 1) * 64);</a>
<a name="ln703">			pEntry-&gt;FileName[0] = 0x00;</a>
<a name="ln704">		}</a>
<a name="ln705"> </a>
<a name="ln706">		// Flush Directory to disk</a>
<a name="ln707">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln708">		fwrite(Directory, 4096, 1, disk);			// Write 4096 bytes for the Directory</a>
<a name="ln709"> </a>
<a name="ln710">//		printf(&quot;Complete: file %s starts at block %lld, directory entry #%d.\n&quot;, filename, new_file_start, first_free_entry);</a>
<a name="ln711">		printf(&quot;Complete\n&quot;);</a>
<a name="ln712">	}</a>
<a name="ln713">	else</a>
<a name="ln714">	{</a>
<a name="ln715">		printf(&quot;Error: File already exists.\n&quot;);</a>
<a name="ln716">	}</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719"> </a>
<a name="ln720">void read(char *filename)</a>
<a name="ln721">{</a>
<a name="ln722">	struct BMFSEntry tempentry;</a>
<a name="ln723">	FILE *tfile;</a>
<a name="ln724">	int tint, slot;</a>
<a name="ln725"> </a>
<a name="ln726">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln727">	{</a>
<a name="ln728">		printf(&quot;Error: File not found in BMFS.\n&quot;);</a>
<a name="ln729">	}</a>
<a name="ln730">	else</a>
<a name="ln731">	{</a>
<a name="ln732">		printf(&quot;Reading '%s' from BMFS to local file... &quot;, filename);</a>
<a name="ln733">		if ((tfile = fopen(tempentry.FileName, &quot;wb&quot;)) == NULL)</a>
<a name="ln734">		{</a>
<a name="ln735">			printf(&quot;Error: Could not open local file '%s'\n&quot;, tempentry.FileName);</a>
<a name="ln736">		}</a>
<a name="ln737">		else</a>
<a name="ln738">		{</a>
<a name="ln739">			fseek(disk, tempentry.StartingBlock*2097152, SEEK_SET); // Skip to the starting block in the disk</a>
<a name="ln740">			for (tint=0; tint&lt;tempentry.FileSize; tint++)</a>
<a name="ln741">			{</a>
<a name="ln742">				putc(getc(disk), tfile);			// This is really terrible.</a>
<a name="ln743">				// TODO: Rework with fread and fwrite (ideally with a 2MiB buffer)</a>
<a name="ln744">			}</a>
<a name="ln745">			fclose(tfile);</a>
<a name="ln746">			printf(&quot;Complete\n&quot;);</a>
<a name="ln747">		}</a>
<a name="ln748">	}</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751"> </a>
<a name="ln752">void write(char *filename)</a>
<a name="ln753">{</a>
<a name="ln754">	struct BMFSEntry tempentry;</a>
<a name="ln755">	FILE *tfile;</a>
<a name="ln756">	int tint, slot;</a>
<a name="ln757">	unsigned long long tempfilesize;</a>
<a name="ln758"> </a>
<a name="ln759">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln760">	{</a>
<a name="ln761">		printf(&quot;Error: File not found in BMFS. A file entry must first be created.\n&quot;);</a>
<a name="ln762">	}</a>
<a name="ln763">	else</a>
<a name="ln764">	{</a>
<a name="ln765">		printf(&quot;Writing local file '%s' to BMFS... &quot;, filename);</a>
<a name="ln766">		if ((tfile = fopen(filename, &quot;rb&quot;)) == NULL)</a>
<a name="ln767">		{</a>
<a name="ln768">			printf(&quot;Error: Could not open local file '%s'\n&quot;, tempentry.FileName);</a>
<a name="ln769">		}</a>
<a name="ln770">		else</a>
<a name="ln771">		{</a>
<a name="ln772">			// Is there enough room in BMFS?</a>
<a name="ln773">			fseek(tfile, 0, SEEK_END);</a>
<a name="ln774">			tempfilesize = ftell(tfile);</a>
<a name="ln775">			rewind(tfile);</a>
<a name="ln776">			if ((tempentry.ReservedBlocks*2097152) &lt; tempfilesize)</a>
<a name="ln777">			{</a>
<a name="ln778">				printf(&quot;Not enough reserved space in BMFS.\n&quot;);</a>
<a name="ln779">			}</a>
<a name="ln780">			else</a>
<a name="ln781">			{</a>
<a name="ln782">				fseek(disk, tempentry.StartingBlock*2097152, SEEK_SET); // Skip to the starting block in the disk</a>
<a name="ln783">				for (tint=0; tint&lt;tempfilesize; tint++)</a>
<a name="ln784">				{</a>
<a name="ln785">					putc(getc(tfile), disk);			// This is really terrible.</a>
<a name="ln786">					// TODO: Rework with fread and fwrite (ideally with a 2MiB buffer)</a>
<a name="ln787">				}</a>
<a name="ln788">				// Update directory</a>
<a name="ln789">				memcpy(Directory+(slot*64)+48, &amp;tempfilesize, 8);</a>
<a name="ln790">				fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln791">				fwrite(Directory, 4096, 1, disk);			// Write new directory to disk</a>
<a name="ln792">				printf(&quot;Complete\n&quot;);</a>
<a name="ln793">			}</a>
<a name="ln794">			fclose(tfile);</a>
<a name="ln795">		}</a>
<a name="ln796">	}</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799"> </a>
<a name="ln800">void delete(char *filename)</a>
<a name="ln801">{</a>
<a name="ln802">	struct BMFSEntry tempentry;</a>
<a name="ln803">	char delmarker = 0x01;</a>
<a name="ln804">	int slot;</a>
<a name="ln805"> </a>
<a name="ln806">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln807">	{</a>
<a name="ln808">		printf(&quot;Error: File not found in BMFS.\n&quot;);</a>
<a name="ln809">	}</a>
<a name="ln810">	else</a>
<a name="ln811">	{</a>
<a name="ln812">		printf(&quot;Deleting file '%s' from BMFS... &quot;, filename);</a>
<a name="ln813">		// Update directory</a>
<a name="ln814">		memcpy(Directory+(slot*64), &amp;delmarker, 1);</a>
<a name="ln815">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln816">		fwrite(Directory, 4096, 1, disk);			// Write new directory to disk				</a>
<a name="ln817">		printf(&quot;Complete\n&quot;);</a>
<a name="ln818">	}</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821"> </a>
<a name="ln822">/* EOF */</a>
</code></pre>
<div class="balloon" rel="1"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v009/" target="_blank">V009</a> To use free version of PVS-Studio, source code files are required to start with a special comment.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
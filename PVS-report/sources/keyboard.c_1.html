<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>keyboard.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &quot;keyboard.h&quot;</a>
<a name="ln5">#include &quot;lib.h&quot;</a>
<a name="ln6">#include &quot;naiveConsole.h&quot;</a>
<a name="ln7">#include &quot;videoDriver.h&quot;</a>
<a name="ln8">#include &quot;synchro.h&quot;</a>
<a name="ln9">#include &quot;scheduler.h&quot;</a>
<a name="ln10">#include &quot;pipes.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#define KEYBOARD_SEM_NAME &quot;keyboard&quot;</a>
<a name="ln13"> </a>
<a name="ln14">// Variable global exportada para que ASM pueda accederla</a>
<a name="ln15">const uint8_t SNAPSHOT_KEY = LEFT_CONTROL; // TODO: cambiarlo por otra</a>
<a name="ln16"> </a>
<a name="ln17">static int shift = 0 ;</a>
<a name="ln18">static int caps_lock = 0;</a>
<a name="ln19">static int control = 0;</a>
<a name="ln20">static int copied_registers=0;</a>
<a name="ln21"> </a>
<a name="ln22">uint16_t buffer_start = 0; // índice del buffer del próximo carácter a leer </a>
<a name="ln23">uint16_t buffer_end = 0; // índice del buffer donde se va a escribir el próximo caracter recibido en el teclado</a>
<a name="ln24">uint16_t buffer_current_size = 0; // cantidad de caracteres en el buffer actual (listos para ser leídos)</a>
<a name="ln25"> </a>
<a name="ln26">static uint8_t buffer[BUFFER_LENGTH];</a>
<a name="ln27">static char reg_buff[800]; // ACA FIJARNOS QUÉ TAMAÑO NOS CONVIENE</a>
<a name="ln28"> </a>
<a name="ln29">static void write_buffer(unsigned char c);</a>
<a name="ln30"> </a>
<a name="ln31">static const char lower_keys[] = {</a>
<a name="ln32">      0,   27, '1', '2', '3', '4', '5', '6', '7', '8', '9',  '0', '-', '=',</a>
<a name="ln33">   '\b', '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',  '[', ']',</a>
<a name="ln34">   '\n',    0, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`',</a>
<a name="ln35">      0, '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/',    0, '*',</a>
<a name="ln36">      0,  ' ',   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,</a>
<a name="ln37">      0,    0,   38,   0, '-',   37,   0,   39, '+',   0,   40,   0,    0,   0,</a>
<a name="ln38">      0,    0,   0,   0,   0,   0,   0,   0,  0,    0,   0,   0,    0,   0,</a>
<a name="ln39">};</a>
<a name="ln40"> </a>
<a name="ln41">static const char upper_keys[] = {</a>
<a name="ln42">      0,   27, '!', '@', '#', '$', '%', '^', '&amp;', '*', '(', ')', '_', '+',</a>
<a name="ln43">   '\b', '\t', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}',</a>
<a name="ln44">   '\n',    0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '&quot;', '~',</a>
<a name="ln45">      0, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '&lt;', '&gt;', '?',   0, '*',</a>
<a name="ln46">      0, ' ',    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln47">      0,   0,    0,   0, '-',   0,   0,   0, '+',   0,   0,   0,   0,   0,</a>
<a name="ln48">      0,   0,    0,   0,   0,   0</a>
<a name="ln49">};</a>
<a name="ln50"> </a>
<a name="ln51">static const char * scancode_to_ascii[] = {lower_keys, upper_keys};</a>
<a name="ln52"> </a>
<a name="ln53">static uint8_t pressed_keys[LETTERS] = {0};</a>
<a name="ln54"> </a>
<a name="ln55">// Inicializa el semáforo del teclado</a>
<a name="ln56">void init_keyboard_sem() {</a>
<a name="ln57">    sem_open(KEYBOARD_SEM_NAME, 0);  // Empieza en 0 (sin caracteres disponibles)</a>
<a name="ln58">}</a>
<a name="ln59">// Static porque no queremos que se pueda acceder desde otro archivo</a>
<a name="ln60">static void write_buffer(unsigned char c) {</a>
<a name="ln61">    buffer[buffer_end] = c;</a>
<a name="ln62">    buffer_end = (buffer_end + 1) % BUFFER_LENGTH; // si hay buffer overflow, se pisa lo del principio (jodete usuario)</a>
<a name="ln63">    buffer_current_size = (buffer_current_size + 1) % BUFFER_LENGTH;</a>
<a name="ln64">    </a>
<a name="ln65">    // Post al semáforo para indicar que hay un carácter disponible</a>
<a name="ln66">    sem_post(KEYBOARD_SEM_NAME);</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">void clear_buffer() {</a>
<a name="ln70">    buffer_end = buffer_start = buffer_current_size = 0;</a>
<a name="ln71">    </a>
<a name="ln72">    // Resetear el semáforo: cerrar y reabrir en 0</a>
<a name="ln73">    sem_close(KEYBOARD_SEM_NAME);</a>
<a name="ln74">    sem_open(KEYBOARD_SEM_NAME, 0);</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">uint8_t get_char_from_buffer() {</a>
<a name="ln78">	if(buffer_current_size == 0){</a>
<a name="ln79">		return -1;</a>
<a name="ln80">	}</a>
<a name="ln81">	--buffer_current_size;</a>
<a name="ln82">	uint8_t result = buffer[buffer_start];</a>
<a name="ln83">	buffer_start = (buffer_start + 1) % BUFFER_LENGTH;</a>
<a name="ln84">	return result;</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">// copia en el buff lo que hay en el buffer de teclado hasta count y va vaciando el buffer de teclado</a>
<a name="ln88">// Bloquea hasta tener TODOS los caracteres pedidos (comportamiento idéntico a pipes)</a>
<a name="ln89">uint64_t read_keyboard_buffer (char * buff_copy, uint64_t count) {</a>
<a name="ln90">    int current_pid = scheduler_get_current_pid();</a>
<a name="ln91">    int foreground_pid = scheduler_get_foreground_pid();</a>
<a name="ln92">    </a>
<a name="ln93">    // Solo el proceso en foreground puede leer del teclado</a>
<a name="ln94">    if (current_pid != foreground_pid) {</a>
<a name="ln95">        return EOF;  // Error: proceso no está en foreground</a>
<a name="ln96">    }</a>
<a name="ln97"> </a>
<a name="ln98">    for (int i = 0; i &lt; count; i++) {</a>
<a name="ln99">        sem_wait(KEYBOARD_SEM_NAME);  // Bloquea hasta que haya un carácter disponible</a>
<a name="ln100">        buff_copy[i] = get_char_from_buffer();</a>
<a name="ln101">    }</a>
<a name="ln102">    return count;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">void handle_pressed_key() {</a>
<a name="ln107">    unsigned char scancode = get_pressed_key(); // this function retrieves the pressed key's scancode</a>
<a name="ln108"> </a>
<a name="ln109">    if (scancode == LEFT_SHIFT || scancode == RIGHT_SHIFT){ </a>
<a name="ln110">        shift = 1;</a>
<a name="ln111">    } else if (scancode == LEFT_SHIFT + BREAKCODE_OFFSET || scancode == RIGHT_SHIFT + BREAKCODE_OFFSET) { </a>
<a name="ln112">        shift = 0;</a>
<a name="ln113">    } else if (scancode == LEFT_CONTROL || scancode == RIGHT_CONTROL) {</a>
<a name="ln114">        control = 1;</a>
<a name="ln115">    } else if (scancode == LEFT_CONTROL + BREAKCODE_OFFSET || scancode == RIGHT_CONTROL + BREAKCODE_OFFSET) {</a>
<a name="ln116">        control = 0;</a>
<a name="ln117">    } else if (scancode == SNAPSHOT_KEY) {  // Usa la variable global</a>
<a name="ln118">        copied_registers = 1;</a>
<a name="ln119">        store_snapshot();</a>
<a name="ln120">        return; </a>
<a name="ln121">    } else if (scancode == CAPS_LOCK) {</a>
<a name="ln122">        caps_lock = (caps_lock+1)%2;</a>
<a name="ln123">    } else if (scancode == 0){</a>
<a name="ln124">        return;</a>
<a name="ln125">    }else if (scancode &gt; BREAKCODE_OFFSET){ // se soltó una tecla o es un caracter no imprimible</a>
<a name="ln126">        char raw = lower_keys[scancode - BREAKCODE_OFFSET]; </a>
<a name="ln127">        if (raw &gt;= 'a' &amp;&amp; raw &lt;= 'z') {</a>
<a name="ln128">            pressed_keys[raw-'a'] = 0; // marcamos la tecla como no presionada</a>
<a name="ln129">        }</a>
<a name="ln130">        return;</a>
<a name="ln131">    } </a>
<a name="ln132">    else if (scancode == UP_ARROW || scancode == DOWN_ARROW || scancode == LEFT_ARROW || scancode == RIGHT_ARROW || scancode==0){  </a>
<a name="ln133">        return;</a>
<a name="ln134">    } </a>
<a name="ln135">    else {</a>
<a name="ln136">        int index;                      </a>
<a name="ln137">        char raw = lower_keys[scancode]; </a>
<a name="ln138">        int is_letter = (raw &gt;= 'a' &amp;&amp; raw &lt;= 'z');  </a>
<a name="ln139"> </a>
<a name="ln140">        if (is_letter &amp;&amp; raw == 'c' &amp;&amp; control) {</a>
<a name="ln141">            if (!pressed_keys['c' - 'a']) {            // para que solo se llame una vez</a>
<a name="ln142">                scheduler_kill_foreground_process();</a>
<a name="ln143">            }</a>
<a name="ln144">            pressed_keys['c' - 'a'] = 1;               // marcamos como presionada</a>
<a name="ln145">            return;                                   // para no meter la 'c' en el buffer</a>
<a name="ln146">        }</a>
<a name="ln147"> </a>
<a name="ln148">        if (is_letter &amp;&amp; raw == 'd' &amp;&amp; control) {</a>
<a name="ln149">            if (!pressed_keys['d' - 'a']) {            // para que solo se llame una vez</a>
<a name="ln150">                pid_t fg_pid = scheduler_get_foreground_pid();</a>
<a name="ln151">                PCB * fg_process = scheduler_get_process(fg_pid);</a>
<a name="ln152">                if (fg_process){</a>
<a name="ln153">                    if(fg_process-&gt;read_fd == STDIN) {</a>
<a name="ln154">                    write_buffer(EOF);</a>
<a name="ln155">                    } else{</a>
<a name="ln156">                        char c = EOF;</a>
<a name="ln157">                        write_pipe(fg_process-&gt;read_fd + 1, &amp;c, 1);</a>
<a name="ln158">                    }</a>
<a name="ln159"> </a>
<a name="ln160">                }</a>
<a name="ln161">            }</a>
<a name="ln162">            pressed_keys['d' - 'a'] = 1;               // marcamos como presionada</a>
<a name="ln163">            return;                                   // para no meter la 'd' en el buffer</a>
<a name="ln164">        }</a>
<a name="ln165"> </a>
<a name="ln166">        if (is_letter) {</a>
<a name="ln167">            index = shift ^ caps_lock;</a>
<a name="ln168">            pressed_keys[raw-'a'] = 1;</a>
<a name="ln169">        } else {</a>
<a name="ln170">            index = shift;                      </a>
<a name="ln171">        }</a>
<a name="ln172"> </a>
<a name="ln173">        write_buffer(scancode_to_ascii[index][scancode]);</a>
<a name="ln174">		// vd_put_char(scancode_to_ascii[index][scancode], 0xffffff);</a>
<a name="ln175">    }</a>
<a name="ln176"> </a>
<a name="ln177">    return;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">void write_string_in_buffer(const char *str) {</a>
<a name="ln181">    while (*str) {</a>
<a name="ln182">        write_buffer((unsigned char)*str);</a>
<a name="ln183">        str++;</a>
<a name="ln184">    }</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">uint8_t is_pressed_key(char c) {</a>
<a name="ln188">    if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z')) { </a>
<a name="ln189">        c = (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ? c - 'A' + 'a' : c; // Convertir a minúscula si es mayúscula</a>
<a name="ln190">        return pressed_keys[c-'a']; // Devuelve 1 si la tecla está presionada, 0 si no</a>
<a name="ln191">    }</a>
<a name="ln192">    return 0; // Si el char es inválido, retornamos 0</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">void store_snapshot(){</a>
<a name="ln196">  char * reg_labels[] = {&quot;RAX:    0x&quot;, &quot;RBX:    0x&quot;, &quot;RCX:    0x&quot;, &quot;RDI:    0x&quot;, &quot;RBP:    0x&quot;, &quot;RDI:    0x&quot;, &quot;RSI:    0x&quot;,  </a>
<a name="ln197">    &quot;R8:     0x&quot;, &quot;R9:     0x&quot;, &quot;R10:    0x&quot;, &quot;R11:    0x&quot;, &quot;R12:    0x&quot;, &quot;R13:    0x&quot;, &quot;R14:    0x&quot;, &quot;R15:    0x&quot;,&quot;RIP:    0x&quot;,&quot;CS:     0x&quot;,&quot;RFLAGS: 0x&quot;,&quot;RSP:    0x&quot;, &quot;SS:     0x&quot;, 0};</a>
<a name="ln198">  uint32_t j = 0; //índice de reg_buff</a>
<a name="ln199"> </a>
<a name="ln200">  for(int i=0 ; reg_labels[i] ; ++i){</a>
<a name="ln201">    //Agregamos el string al buffer</a>
<a name="ln202">    for(int m=0; reg_labels[i][m]; ++m){</a>
<a name="ln203">      reg_buff[j++] = reg_labels[i][m];</a>
<a name="ln204">    }</a>
<a name="ln205"> </a>
<a name="ln206">    //Agregamos el nro al buffer. Quiero que todos me queden con 16 dígitos hexadecimales</a>
<a name="ln207">    j += uint64_to_register_format(reg_array[i], reg_buff + j);</a>
<a name="ln208">    reg_buff[j++] = '\n';</a>
<a name="ln209">  }</a>
<a name="ln210">  reg_buff[j] = 0;</a>
<a name="ln211">  // print_registers();</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">// devuelve la cantidad de caracteres escritos</a>
<a name="ln215">uint32_t uint64_to_register_format(uint64_t value, char *dest) {</a>
<a name="ln216">    int64_t zeros_to_pad = 16;</a>
<a name="ln217">    uint64_t aux = value;</a>
<a name="ln218"> </a>
<a name="ln219">    // Calcular cuántos ceros hay que agregar</a>
<a name="ln220">    while (aux) {</a>
<a name="ln221">        aux &gt;&gt;= 4;</a>
<a name="ln222">        zeros_to_pad--;</a>
<a name="ln223">    }</a>
<a name="ln224"> </a>
<a name="ln225">    uint32_t j = 0;</a>
<a name="ln226">    // Agregar los ceros necesarios</a>
<a name="ln227">    for (int i = 0; i &lt; zeros_to_pad; i++) {</a>
<a name="ln228">        dest[j++] = '0';</a>
<a name="ln229">    }</a>
<a name="ln230"> </a>
<a name="ln231">    // Escribir la parte significativa si value ≠ 0</a>
<a name="ln232">    if (value) {</a>
<a name="ln233">        j += uintToBase(value, dest + j, 16);</a>
<a name="ln234">    }</a>
<a name="ln235"> </a>
<a name="ln236">    dest[j] = 0; // null-terminador por si hace falta usarlo como string</a>
<a name="ln237">    return j;    // devuelve la cantidad de caracteres escritos</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240"> </a>
<a name="ln241">//devuelve 1 si ya se llamo a ctrl s y 0 si todavia no se llamo</a>
<a name="ln242">//dejamos en copy un string con el nombre del registro y su valor (cada registro separado por un n)</a>
<a name="ln243">uint64_t copy_registers(char * copy){</a>
<a name="ln244">    if (!copied_registers){</a>
<a name="ln245">        return 0;</a>
<a name="ln246">    }</a>
<a name="ln247">    int i;</a>
<a name="ln248">    for (i=0 ; reg_buff[i] ; i++){</a>
<a name="ln249">        copy[i]=reg_buff[i];</a>
<a name="ln250">    }</a>
<a name="ln251">    copy[i] = 0;</a>
<a name="ln252">    return 1;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">// void print_registers() {</a>
<a name="ln256">//     ncClear();</a>
<a name="ln257">//     for (int i = 0; reg_buff[i] != 0; i++) {</a>
<a name="ln258">//         ncPrintChar(reg_buff[i]);</a>
<a name="ln259">//     }</a>
<a name="ln260">// }</a>
</code></pre>
<div class="balloon" rel="117"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'scancode == SNAPSHOT_KEY' is always false.</p></div>
<div class="balloon" rel="137"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'scancode' index could reach 128.</p></div>
<div class="balloon" rel="113"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: scancode == 0xE01D. The value range of unsigned char type: [0, 255].</p></div>
<div class="balloon" rel="115"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: scancode == 0xE01D + 0x80. The value range of unsigned char type: [0, 255].</p></div>
<div class="balloon" rel="132"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: scancode == 0.</p></div>
<div class="balloon" rel="189"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: c &gt;= 'A'.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
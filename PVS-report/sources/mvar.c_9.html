<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>mvar.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &quot;usrlib.h&quot;</a>
<a name="ln5"> </a>
<a name="ln6">#define MAX_SEM_NAME_LENGTH 64 // TODO: se comparte con Kernel</a>
<a name="ln7">#define SEM_PREFIX &quot;mvar_&quot;</a>
<a name="ln8">#define SEM_EMPTY_SUFFIX &quot;empty_&quot;</a>
<a name="ln9">#define SEM_FULL_SUFFIX  &quot;full_&quot;</a>
<a name="ln10"> </a>
<a name="ln11">#define LETTER_POOL &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</a>
<a name="ln12">#define LETTER_POOL_SIZE (sizeof(LETTER_POOL) - 1)</a>
<a name="ln13"> </a>
<a name="ln14">#define COLOR_COUNT 5</a>
<a name="ln15">#define MIN_SLEEP_MS 100</a>
<a name="ln16">#define SLEEP_JITTER_MS 250</a>
<a name="ln17"> </a>
<a name="ln18">static char volatile mvar_value = 0;</a>
<a name="ln19">static char sem_empty_name[MAX_SEM_NAME_LENGTH];</a>
<a name="ln20">static char sem_full_name[MAX_SEM_NAME_LENGTH];</a>
<a name="ln21"> </a>
<a name="ln22">static const int color_fds[COLOR_COUNT] = {STDOUT, STDGREEN, STDBLUE, STDMAGENTA, STDYELLOW};</a>
<a name="ln23"> </a>
<a name="ln24">static void build_sem_name(char *target, const char *suffix, uint64_t pid);</a>
<a name="ln25">static void setup_sem_names(void);</a>
<a name="ln26">static int attach_to_sync_objects(void);</a>
<a name="ln27">static void random_pause(void);</a>
<a name="ln28">static char letter_for_writer(int index);</a>
<a name="ln29">static int spawn_writer(int index);</a>
<a name="ln30">static int spawn_reader(int index);</a>
<a name="ln31">static int writer_process(int argc, char *argv[]);</a>
<a name="ln32">static int reader_process(int argc, char *argv[]);</a>
<a name="ln33"> </a>
<a name="ln34">int mvar_main(int argc, char *argv[]) {</a>
<a name="ln35">    if (argc != 2) {</a>
<a name="ln36">        print_err(&quot;Uso: mvar &lt;num_escritores&gt; &lt;num_lectores&gt;\n&quot;);</a>
<a name="ln37">        return ERROR;</a>
<a name="ln38">    }</a>
<a name="ln39"> </a>
<a name="ln40">    int num_writers = satoi(argv[0]);</a>
<a name="ln41">    int num_readers = satoi(argv[1]);</a>
<a name="ln42"> </a>
<a name="ln43">    if (num_writers &lt;= 0 || num_readers &lt;= 0) {</a>
<a name="ln44">        print_err(&quot;mvar: los par치metros deben ser enteros positivos.\n&quot;);</a>
<a name="ln45">        print_err(&quot;Uso: mvar &lt;num_escritores&gt; &lt;num_lectores&gt;\n&quot;);</a>
<a name="ln46">        return ERROR;</a>
<a name="ln47">    }</a>
<a name="ln48"> </a>
<a name="ln49">    if (num_writers &gt; (int)LETTER_POOL_SIZE) {</a>
<a name="ln50">        print_err(&quot;mvar: cantidad m치xima de escritores soportada es 62.\n&quot;);</a>
<a name="ln51">        return ERROR;</a>
<a name="ln52">    }</a>
<a name="ln53"> </a>
<a name="ln54">    setup_sem_names();</a>
<a name="ln55"> </a>
<a name="ln56">    for (int i = 0; i &lt; num_writers; i++) {</a>
<a name="ln57">        if (spawn_writer(i) &lt; 0) {</a>
<a name="ln58">            print_err(&quot;mvar: error creando un escritor.\n&quot;);</a>
<a name="ln59">            return ERROR;</a>
<a name="ln60">        }</a>
<a name="ln61">    }</a>
<a name="ln62"> </a>
<a name="ln63">    for (int i = 0; i &lt; num_readers; i++) {</a>
<a name="ln64">        if (spawn_reader(i) &lt; 0) {</a>
<a name="ln65">            print_err(&quot;mvar: error creando un lector.\n&quot;);</a>
<a name="ln66">            return ERROR;</a>
<a name="ln67">        }</a>
<a name="ln68">    }</a>
<a name="ln69"> </a>
<a name="ln70">    printf(&quot;mvar: %d escritores y %d lectores lanzados.\n&quot;, num_writers, num_readers);</a>
<a name="ln71">    return OK;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">static void build_sem_name(char *target, const char *suffix, uint64_t pid) {</a>
<a name="ln75">    char pid_buf[DECIMAL_BUFFER_SIZE];</a>
<a name="ln76">    num_to_str_base(pid, pid_buf, 10);</a>
<a name="ln77"> </a>
<a name="ln78">    int idx = 0;</a>
<a name="ln79">    const char *prefix = SEM_PREFIX;</a>
<a name="ln80"> </a>
<a name="ln81">    while (prefix[idx] != 0 &amp;&amp; idx &lt; MAX_SEM_NAME_LENGTH - 1) {</a>
<a name="ln82">        target[idx] = prefix[idx];</a>
<a name="ln83">        idx++;</a>
<a name="ln84">    }</a>
<a name="ln85"> </a>
<a name="ln86">    for (int i = 0; suffix[i] != 0 &amp;&amp; idx &lt; MAX_SEM_NAME_LENGTH - 1; i++) {</a>
<a name="ln87">        target[idx++] = suffix[i];</a>
<a name="ln88">    }</a>
<a name="ln89"> </a>
<a name="ln90">    for (int i = 0; pid_buf[i] != 0 &amp;&amp; idx &lt; MAX_SEM_NAME_LENGTH - 1; i++) {</a>
<a name="ln91">        target[idx++] = pid_buf[i];</a>
<a name="ln92">    }</a>
<a name="ln93"> </a>
<a name="ln94">    target[idx] = 0;</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">static void setup_sem_names(void) {</a>
<a name="ln98">    uint64_t pid = sys_getpid();</a>
<a name="ln99">    build_sem_name(sem_empty_name, SEM_EMPTY_SUFFIX, pid);</a>
<a name="ln100">    build_sem_name(sem_full_name, SEM_FULL_SUFFIX, pid);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">static int attach_to_sync_objects(void) {</a>
<a name="ln104">    if (sys_sem_open(sem_empty_name, 1) &lt; 0) {</a>
<a name="ln105">        return ERROR;</a>
<a name="ln106">    }</a>
<a name="ln107">    if (sys_sem_open(sem_full_name, 0) &lt; 0) {</a>
<a name="ln108">        return ERROR;</a>
<a name="ln109">    }</a>
<a name="ln110">    return OK;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">static void random_pause(void) {</a>
<a name="ln114">    uint64_t delay = MIN_SLEEP_MS + get_uniform(SLEEP_JITTER_MS);</a>
<a name="ln115">    sys_sleep(delay);</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">static char letter_for_writer(int index) {</a>
<a name="ln119">    if (index &lt; (int)LETTER_POOL_SIZE) {</a>
<a name="ln120">        return LETTER_POOL[index];</a>
<a name="ln121">    }</a>
<a name="ln122">    return '?';</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static int spawn_writer(int index) {</a>
<a name="ln126">    char idx_buf[DECIMAL_BUFFER_SIZE];</a>
<a name="ln127">    num_to_str_base((uint64_t)index, idx_buf, 10);</a>
<a name="ln128">    char *writer_argv[] = {idx_buf, NULL};</a>
<a name="ln129"> </a>
<a name="ln130">    int pid = (int)sys_create_process(&amp;writer_process, 1, (const char **)writer_argv, &quot;mvar_writer&quot;, NULL);</a>
<a name="ln131">    return pid &lt; 0 ? ERROR : OK;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">static int spawn_reader(int index) {</a>
<a name="ln135">    char idx_buf[DECIMAL_BUFFER_SIZE];</a>
<a name="ln136">    num_to_str_base((uint64_t)index, idx_buf, 10);</a>
<a name="ln137">    char *reader_argv[] = {idx_buf, NULL};</a>
<a name="ln138"> </a>
<a name="ln139">    int pid = (int)sys_create_process(&amp;reader_process, 1, (const char **)reader_argv, &quot;mvar_reader&quot;, NULL);</a>
<a name="ln140">    return pid &lt; 0 ? ERROR : OK;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">static int writer_process(int argc, char *argv[]) {</a>
<a name="ln144">    if (argc != 1 || argv[0] == NULL) {</a>
<a name="ln145">        return ERROR;</a>
<a name="ln146">    }</a>
<a name="ln147"> </a>
<a name="ln148">    if (attach_to_sync_objects() &lt; 0) {</a>
<a name="ln149">        print_err(&quot;writer: no se pudieron abrir los sem치foros.\n&quot;);</a>
<a name="ln150">        return ERROR;</a>
<a name="ln151">    }</a>
<a name="ln152"> </a>
<a name="ln153">    int idx = (int)satoi(argv[0]);</a>
<a name="ln154"> </a>
<a name="ln155">    char letter = letter_for_writer(idx);</a>
<a name="ln156"> </a>
<a name="ln157">    while (1) {</a>
<a name="ln158">        random_pause();</a>
<a name="ln159">        sys_sem_wait(sem_empty_name);</a>
<a name="ln160">        mvar_value = letter;</a>
<a name="ln161">        sys_sem_post(sem_full_name);</a>
<a name="ln162">    }</a>
<a name="ln163">    return OK;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">static int reader_process(int argc, char *argv[]) {</a>
<a name="ln167">    if (argc != 1 || argv[0] == NULL) {</a>
<a name="ln168">        return ERROR;</a>
<a name="ln169">    }</a>
<a name="ln170"> </a>
<a name="ln171">    if (attach_to_sync_objects() &lt; 0) {</a>
<a name="ln172">        print_err(&quot;reader: no se pudieron abrir los sem치foros.\n&quot;);</a>
<a name="ln173">        return ERROR;</a>
<a name="ln174">    }</a>
<a name="ln175"> </a>
<a name="ln176">    int idx = (int)satoi(argv[0]);</a>
<a name="ln177">    </a>
<a name="ln178">    int color = color_fds[idx % COLOR_COUNT];</a>
<a name="ln179"> </a>
<a name="ln180">    while (1) {</a>
<a name="ln181">        random_pause();</a>
<a name="ln182">        sys_sem_wait(sem_full_name);</a>
<a name="ln183"> </a>
<a name="ln184">        char c = mvar_value;</a>
<a name="ln185">        mvar_value = 0;</a>
<a name="ln186"> </a>
<a name="ln187">        sys_sem_post(sem_empty_name);</a>
<a name="ln188"> </a>
<a name="ln189">        sys_write(color, &amp;c, 1);</a>
<a name="ln190">        char space = ' ';</a>
<a name="ln191">        sys_write(color, &amp;space, 1);</a>
<a name="ln192">    }</a>
<a name="ln193"> </a>
<a name="ln194">    return OK;</a>
<a name="ln195">}</a>
</code></pre>
<div class="balloon" rel="81"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v781/" target="_blank">V781</a> The value of the 'idx' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>
<div class="balloon" rel="82"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'idx' index could reach 62.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
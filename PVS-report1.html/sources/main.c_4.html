<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>main.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;stdio.h&gt;</a>
<a name="ln5">#include &lt;unistd.h&gt;</a>
<a name="ln6">#include &lt;stdint.h&gt;</a>
<a name="ln7">#include &lt;sys/stat.h&gt;</a>
<a name="ln8">#include &lt;stdlib.h&gt;</a>
<a name="ln9">#include &lt;argp.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;modulePacker.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13">//Parser elements</a>
<a name="ln14">const char *argp_program_version =</a>
<a name="ln15">  &quot;x64BareBones ModulePacker (C) v0.2&quot;;</a>
<a name="ln16">const char *argp_program_bug_address =</a>
<a name="ln17">  &quot;arq-catedra@googlegroups.com&quot;;</a>
<a name="ln18"> </a>
<a name="ln19">/* Program documentation. */</a>
<a name="ln20">static char doc[] =</a>
<a name="ln21">  &quot;ModulePacker is an appender of binary files to be loaded all together&quot;;</a>
<a name="ln22"> </a>
<a name="ln23">/* A description of the arguments we accept. */</a>
<a name="ln24">static char args_doc[] = &quot;KernelFile Module1 Module2 ...&quot;;</a>
<a name="ln25"> </a>
<a name="ln26">/* The options we understand. */</a>
<a name="ln27">static struct argp_option options[] = {</a>
<a name="ln28">  {&quot;output&quot;,   'o', &quot;FILE&quot;, 0,</a>
<a name="ln29">   &quot;Output to FILE instead of standard output&quot; },</a>
<a name="ln30">  { 0 }</a>
<a name="ln31">};</a>
<a name="ln32"> </a>
<a name="ln33">/* Our argp parser. */</a>
<a name="ln34">static struct argp argp = { options, parse_opt, args_doc, doc };</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">int main(int argc, char *argv[]) {</a>
<a name="ln38">	</a>
<a name="ln39">	struct arguments arguments;</a>
<a name="ln40"> </a>
<a name="ln41">	arguments.output_file = OUTPUT_FILE;</a>
<a name="ln42">	arguments.count = 0;</a>
<a name="ln43"> </a>
<a name="ln44">	argp_parse (&amp;argp, argc, argv, 0, 0, &amp;arguments);</a>
<a name="ln45"> </a>
<a name="ln46">	array_t fileArray = {arguments.args, arguments.count};</a>
<a name="ln47"> </a>
<a name="ln48">	if(!check_files(fileArray)) {</a>
<a name="ln49">		return 1;</a>
<a name="ln50">	}	</a>
<a name="ln51"> </a>
<a name="ln52">	return !build_image(fileArray, arguments.output_file);</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">int build_image(array_t fileArray, char *output_file) {</a>
<a name="ln56"> </a>
<a name="ln57">	FILE *target;</a>
<a name="ln58"> </a>
<a name="ln59">	if((target = fopen(output_file, &quot;w&quot;)) == NULL) {</a>
<a name="ln60">		printf(&quot;Can't create target file\n&quot;);</a>
<a name="ln61">		return FALSE;</a>
<a name="ln62">	}</a>
<a name="ln63"> </a>
<a name="ln64">	//First, write the kernel</a>
<a name="ln65">	FILE *source = fopen(fileArray.array[0], &quot;r&quot;);</a>
<a name="ln66">	write_file(target, source);</a>
<a name="ln67"> </a>
<a name="ln68">	//Write how many extra binaries we got.</a>
<a name="ln69">	int extraBinaries = fileArray.length - 1;</a>
<a name="ln70">	fwrite(&amp;extraBinaries, sizeof(extraBinaries), 1, target);	</a>
<a name="ln71">	fclose(source);</a>
<a name="ln72"> </a>
<a name="ln73">	int i;</a>
<a name="ln74">	for (i = 1 ; i &lt; fileArray.length ; i++) {</a>
<a name="ln75">		FILE *source = fopen(fileArray.array[i], &quot;r&quot;);</a>
<a name="ln76">		</a>
<a name="ln77">		//Write the file size;</a>
<a name="ln78">		write_size(target, fileArray.array[i]);</a>
<a name="ln79"> </a>
<a name="ln80">		//Write the binary</a>
<a name="ln81">		write_file(target, source);</a>
<a name="ln82"> </a>
<a name="ln83">		fclose(source);</a>
<a name="ln84"> </a>
<a name="ln85">	} </a>
<a name="ln86">	fclose(target);</a>
<a name="ln87">	return TRUE;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">int check_files(array_t fileArray) {</a>
<a name="ln92"> </a>
<a name="ln93">	int i = 0;</a>
<a name="ln94">	for(; i &lt; fileArray.length ; i++) {</a>
<a name="ln95">		if(access(fileArray.array[i], R_OK)) {</a>
<a name="ln96">			printf(&quot;Can't open file: %s\n&quot;, fileArray.array[i]);</a>
<a name="ln97">			return FALSE;</a>
<a name="ln98">		}</a>
<a name="ln99">	}</a>
<a name="ln100">	return TRUE;</a>
<a name="ln101"> </a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">int write_size(FILE *target, char *filename) {</a>
<a name="ln105">	struct stat st;</a>
<a name="ln106">	stat(filename, &amp;st);</a>
<a name="ln107">	uint32_t size = st.st_size;</a>
<a name="ln108">	fwrite(&amp;size, sizeof(uint32_t), 1, target);</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">int write_file(FILE *target, FILE *source) {</a>
<a name="ln113">	char buffer[BUFFER_SIZE];</a>
<a name="ln114">	int read;</a>
<a name="ln115"> </a>
<a name="ln116">	while (!feof(source)) {</a>
<a name="ln117">		read = fread(buffer, 1, BUFFER_SIZE, source);</a>
<a name="ln118">		fwrite(buffer, 1, read, target);</a>
<a name="ln119">	}</a>
<a name="ln120"> </a>
<a name="ln121">	return TRUE;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">/* Parse a single option. */</a>
<a name="ln126">static error_t</a>
<a name="ln127">parse_opt (int key, char *arg, struct argp_state *state)</a>
<a name="ln128">{</a>
<a name="ln129">  /* Get the input argument from argp_parse, which we</a>
<a name="ln130">     know is a pointer to our arguments structure. */</a>
<a name="ln131">  struct arguments *arguments = state-&gt;input;</a>
<a name="ln132"> </a>
<a name="ln133">  switch (key)</a>
<a name="ln134">    {</a>
<a name="ln135">    case 'o':</a>
<a name="ln136">      arguments-&gt;output_file = arg;</a>
<a name="ln137">      break;</a>
<a name="ln138"> </a>
<a name="ln139">    case ARGP_KEY_ARG:</a>
<a name="ln140">      arguments-&gt;args[state-&gt;arg_num] = arg;</a>
<a name="ln141">      break;</a>
<a name="ln142"> </a>
<a name="ln143">    case ARGP_KEY_END:</a>
<a name="ln144">      if (state-&gt;arg_num &lt; 1)</a>
<a name="ln145">        argp_usage (state);</a>
<a name="ln146">      arguments-&gt;count = state-&gt;arg_num;</a>
<a name="ln147">      break;</a>
<a name="ln148"> </a>
<a name="ln149">    default:</a>
<a name="ln150">      return ARGP_ERR_UNKNOWN;</a>
<a name="ln151">    }</a>
<a name="ln152">  return 0;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155"> </a>
</code></pre>
<div class="balloon" rel="109"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v591/" target="_blank">V591</a> Non-void function should return a value.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
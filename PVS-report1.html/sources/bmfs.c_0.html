<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bmfs.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com</a>
<a name="ln3"> </a>
<a name="ln4">/* BareMetal File System Utility */</a>
<a name="ln5">/* Written by Ian Seyler of Return Infinity */</a>
<a name="ln6"> </a>
<a name="ln7">/* Global includes */</a>
<a name="ln8">#include &lt;stdio.h&gt;</a>
<a name="ln9">#include &lt;stdlib.h&gt;</a>
<a name="ln10">#include &lt;string.h&gt;</a>
<a name="ln11">#include &lt;strings.h&gt;</a>
<a name="ln12">#include &lt;ctype.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">/* Global defines */</a>
<a name="ln15">struct BMFSEntry</a>
<a name="ln16">{</a>
<a name="ln17">	char FileName[32];</a>
<a name="ln18">	unsigned long long StartingBlock;</a>
<a name="ln19">	unsigned long long ReservedBlocks;</a>
<a name="ln20">	unsigned long long FileSize;</a>
<a name="ln21">	unsigned long long Unused;</a>
<a name="ln22">};</a>
<a name="ln23"> </a>
<a name="ln24">/* Global constants */</a>
<a name="ln25">// Min disk size is 6MiB (three blocks of 2MiB each.)</a>
<a name="ln26">const unsigned long long minimumDiskSize = (6 * 1024 * 1024);</a>
<a name="ln27"> </a>
<a name="ln28">/* Global variables */</a>
<a name="ln29">FILE *file, *disk;</a>
<a name="ln30">unsigned int filesize, disksize;</a>
<a name="ln31">char tempfilename[32], tempstring[32];</a>
<a name="ln32">char *filename, *diskname, *command;</a>
<a name="ln33">char fs_tag[] = &quot;BMFS&quot;;</a>
<a name="ln34">char s_list[] = &quot;list&quot;;</a>
<a name="ln35">char s_format[] = &quot;format&quot;;</a>
<a name="ln36">char s_initialize[] = &quot;initialize&quot;;</a>
<a name="ln37">char s_create[] = &quot;create&quot;;</a>
<a name="ln38">char s_read[] = &quot;read&quot;;</a>
<a name="ln39">char s_write[] = &quot;write&quot;;</a>
<a name="ln40">char s_delete[] = &quot;delete&quot;;</a>
<a name="ln41">struct BMFSEntry entry;</a>
<a name="ln42">void *pentry = &amp;entry;</a>
<a name="ln43">char *BlockMap;</a>
<a name="ln44">char *FileBlocks;</a>
<a name="ln45">char Directory[4096];</a>
<a name="ln46">char DiskInfo[512];</a>
<a name="ln47"> </a>
<a name="ln48">/* Built-in functions */</a>
<a name="ln49">int findfile(char *filename, struct BMFSEntry *fileentry, int *entrynumber);</a>
<a name="ln50">void list();</a>
<a name="ln51">void format();</a>
<a name="ln52">int initialize(char *diskname, char *size, char *mbr, char *boot, char *kernel);</a>
<a name="ln53">void create(char *filename, unsigned long long maxsize);</a>
<a name="ln54">void read(char *filename);</a>
<a name="ln55">void write(char *filename);</a>
<a name="ln56">void delete(char *filename);</a>
<a name="ln57"> </a>
<a name="ln58">/* Program code */</a>
<a name="ln59">int main(int argc, char *argv[])</a>
<a name="ln60">{</a>
<a name="ln61">	/* Parse arguments */</a>
<a name="ln62">	if (argc &lt; 3)</a>
<a name="ln63">	{</a>
<a name="ln64">		printf(&quot;BareMetal File System Utility v1.0 (2013 04 10)\n&quot;);</a>
<a name="ln65">		printf(&quot;Written by Ian Seyler @ Return Infinity (ian.seyler@returninfinity.com)\n\n&quot;);</a>
<a name="ln66">		printf(&quot;Usage: %s disk function file\n&quot;, argv[0]);</a>
<a name="ln67">		printf(&quot;Disk: the name of the disk file\n&quot;);</a>
<a name="ln68">		printf(&quot;Function: list, read, write, create, delete, format, initialize\n&quot;);</a>
<a name="ln69">		printf(&quot;File: (if applicable)\n&quot;);</a>
<a name="ln70">		exit(0);</a>
<a name="ln71">	}</a>
<a name="ln72"> </a>
<a name="ln73">	diskname = argv[1];</a>
<a name="ln74">	command = argv[2];</a>
<a name="ln75">	filename = argv[3];</a>
<a name="ln76"> </a>
<a name="ln77">	if (strcasecmp(s_initialize, command) == 0)</a>
<a name="ln78">	{</a>
<a name="ln79">		if (argc &gt;= 4)</a>
<a name="ln80">		{</a>
<a name="ln81">			char *size = argv[3];  // Required</a>
<a name="ln82">			char *mbr = (argc &gt; 4 ? argv[4] : NULL);    // Opt.</a>
<a name="ln83">			char *boot = (argc &gt; 5 ? argv[5] : NULL);   // Opt.</a>
<a name="ln84">			char *kernel = (argc &gt; 6 ? argv[6] : NULL); // Opt.</a>
<a name="ln85">			int ret = initialize(diskname, size, mbr, boot, kernel);</a>
<a name="ln86">			exit(ret);</a>
<a name="ln87">		}</a>
<a name="ln88">		else</a>
<a name="ln89">		{</a>
<a name="ln90">			printf(&quot;Usage: %s disk %s &quot;, argv[0], command);</a>
<a name="ln91">			printf(&quot;size [mbr_file] &quot;);</a>
<a name="ln92">			printf(&quot;[bootloader_file] [kernel_file]\n&quot;);</a>
<a name="ln93">			exit(1);</a>
<a name="ln94">		}</a>
<a name="ln95">	}</a>
<a name="ln96"> </a>
<a name="ln97">	if ((disk = fopen(diskname, &quot;r+b&quot;)) == NULL)	// Open for read/write in binary mode</a>
<a name="ln98">	{</a>
<a name="ln99">		printf(&quot;Error: Unable to open disk '%s'\n&quot;, diskname);</a>
<a name="ln100">		exit(0);</a>
<a name="ln101">	}</a>
<a name="ln102">	else	// Opened ok, is it a valid BMFS disk?</a>
<a name="ln103">	{</a>
<a name="ln104">		fseek(disk, 0, SEEK_END);</a>
<a name="ln105">		disksize = ftell(disk) / 1048576;			// Disk size in MiB</a>
<a name="ln106">		fseek(disk, 1024, SEEK_SET);				// Seek 1KiB in for disk information</a>
<a name="ln107">		fread(DiskInfo, 512, 1, disk);				// Read 512 bytes to the DiskInfo buffer</a>
<a name="ln108">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln109">		fread(Directory, 4096, 1, disk);			// Read 4096 bytes to the Directory buffer</a>
<a name="ln110">		rewind(disk);</a>
<a name="ln111">		</a>
<a name="ln112">		if (strcasecmp(DiskInfo, fs_tag) != 0)		// Is it a BMFS formatted disk?</a>
<a name="ln113">		{</a>
<a name="ln114">			if (strcasecmp(s_format, command) == 0)</a>
<a name="ln115">			{</a>
<a name="ln116">				format();</a>
<a name="ln117">			}</a>
<a name="ln118">			else</a>
<a name="ln119">			{</a>
<a name="ln120">				printf(&quot;Error: Not a valid BMFS drive (Disk is not BMFS formatted).\n&quot;);</a>
<a name="ln121">			}</a>
<a name="ln122">			fclose(disk);</a>
<a name="ln123">			return 0;</a>
<a name="ln124">		}</a>
<a name="ln125">	}</a>
<a name="ln126"> </a>
<a name="ln127">	if (strcasecmp(s_list, command) == 0)</a>
<a name="ln128">	{</a>
<a name="ln129">		list();</a>
<a name="ln130">	}</a>
<a name="ln131">	else if (strcasecmp(s_format, command) == 0)</a>
<a name="ln132">	{</a>
<a name="ln133">		if (argc &gt; 3)</a>
<a name="ln134">		{</a>
<a name="ln135">			if (strcasecmp(argv[3], &quot;/FORCE&quot;) == 0)</a>
<a name="ln136">			{</a>
<a name="ln137">				format();</a>
<a name="ln138">			}</a>
<a name="ln139">			else</a>
<a name="ln140">			{</a>
<a name="ln141">				printf(&quot;Format aborted!\n&quot;);</a>
<a name="ln142">			}</a>
<a name="ln143">		}</a>
<a name="ln144">		else	</a>
<a name="ln145">		{</a>
<a name="ln146">			printf(&quot;Format aborted!\n&quot;);</a>
<a name="ln147">		}</a>
<a name="ln148">	}</a>
<a name="ln149">	else if (strcasecmp(s_create, command) == 0)</a>
<a name="ln150">	{</a>
<a name="ln151">		if (filename == NULL)</a>
<a name="ln152">		{</a>
<a name="ln153">			printf(&quot;Error: File name not specified.\n&quot;);</a>
<a name="ln154">		}</a>
<a name="ln155">		else</a>
<a name="ln156">		{</a>
<a name="ln157">			if (argc &gt; 4)</a>
<a name="ln158">			{</a>
<a name="ln159">				int filesize = atoi(argv[4]);</a>
<a name="ln160">				if (filesize &gt;= 1)</a>
<a name="ln161">				{</a>
<a name="ln162">					create(filename, filesize);</a>
<a name="ln163">				}</a>
<a name="ln164">				else</a>
<a name="ln165">				{</a>
<a name="ln166">			  		printf(&quot;Error: Invalid file size.\n&quot;);</a>
<a name="ln167">				}</a>
<a name="ln168">			}</a>
<a name="ln169">			else</a>
<a name="ln170">			{</a>
<a name="ln171">				printf(&quot;Maximum file size in MiB: &quot;);</a>
<a name="ln172">				fgets(tempstring, 32, stdin);			// Get up to 32 chars from the keyboard</a>
<a name="ln173">				filesize = atoi(tempstring);</a>
<a name="ln174">				if (filesize &gt;= 1)</a>
<a name="ln175">					create(filename, filesize);</a>
<a name="ln176">				else</a>
<a name="ln177">					printf(&quot;Error: Invalid file size.\n&quot;);</a>
<a name="ln178">			}</a>
<a name="ln179">		}</a>
<a name="ln180">	}</a>
<a name="ln181">	else if (strcasecmp(s_read, command) == 0)</a>
<a name="ln182">	{</a>
<a name="ln183">		read(filename);</a>
<a name="ln184">	}</a>
<a name="ln185">	else if (strcasecmp(s_write, command) == 0)</a>
<a name="ln186">	{</a>
<a name="ln187">		write(filename);</a>
<a name="ln188">	}</a>
<a name="ln189">	else if (strcasecmp(s_delete, command) == 0)</a>
<a name="ln190">	{</a>
<a name="ln191">		delete(filename);</a>
<a name="ln192">	}</a>
<a name="ln193">	else</a>
<a name="ln194">	{</a>
<a name="ln195">		printf(&quot;Unknown command\n&quot;);</a>
<a name="ln196">	}</a>
<a name="ln197">	if (disk != NULL)</a>
<a name="ln198">	{</a>
<a name="ln199">		fclose( disk );</a>
<a name="ln200">		disk = NULL;</a>
<a name="ln201">	}</a>
<a name="ln202">	return 0;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">int findfile(char *filename, struct BMFSEntry *fileentry, int *entrynumber)</a>
<a name="ln207">{</a>
<a name="ln208">	int tint;</a>
<a name="ln209"> </a>
<a name="ln210">	for (tint = 0; tint &lt; 64; tint++)</a>
<a name="ln211">	{</a>
<a name="ln212">		memcpy(pentry, Directory+(tint*64), 64);</a>
<a name="ln213">		if (entry.FileName[0] == 0x00)				// End of directory</a>
<a name="ln214">		{</a>
<a name="ln215">			tint = 64;</a>
<a name="ln216">		}</a>
<a name="ln217">		else if (entry.FileName[0] == 0x01)			// Emtpy entry</a>
<a name="ln218">		{</a>
<a name="ln219">			// Ignore</a>
<a name="ln220">		}</a>
<a name="ln221">		else										// Valid entry</a>
<a name="ln222">		{</a>
<a name="ln223">			if (strcmp(filename, entry.FileName) == 0)</a>
<a name="ln224">			{</a>
<a name="ln225">				memcpy(fileentry, pentry, 64);</a>
<a name="ln226">				*entrynumber = tint;</a>
<a name="ln227">				return 1;</a>
<a name="ln228">			}</a>
<a name="ln229">		}	</a>
<a name="ln230">	}</a>
<a name="ln231">	return 0;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234"> </a>
<a name="ln235">void list()</a>
<a name="ln236">{</a>
<a name="ln237">	int tint;</a>
<a name="ln238"> </a>
<a name="ln239">	printf(&quot;%s\nDisk Size: %d MiB\n&quot;, diskname, disksize);</a>
<a name="ln240">	printf(&quot;Name                            |            Size (B)|      Reserved (MiB)\n&quot;);</a>
<a name="ln241">	printf(&quot;==========================================================================\n&quot;);</a>
<a name="ln242">	for (tint = 0; tint &lt; 64; tint++)			// Max 64 entries</a>
<a name="ln243">	{</a>
<a name="ln244">		memcpy(pentry, Directory+(tint*64), 64);</a>
<a name="ln245">		if (entry.FileName[0] == 0x00)				// End of directory, bail out</a>
<a name="ln246">		{</a>
<a name="ln247">			tint = 64;</a>
<a name="ln248">		}</a>
<a name="ln249">		else if (entry.FileName[0] == 0x01)			// Emtpy entry</a>
<a name="ln250">		{</a>
<a name="ln251">			// Ignore</a>
<a name="ln252">		}</a>
<a name="ln253">		else										// Valid entry</a>
<a name="ln254">		{</a>
<a name="ln255">			printf(&quot;%-32s %20lld %20lld\n&quot;, entry.FileName, entry.FileSize, (entry.ReservedBlocks*2));</a>
<a name="ln256">		}</a>
<a name="ln257">	}</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260"> </a>
<a name="ln261">void format()</a>
<a name="ln262">{</a>
<a name="ln263">	memset(DiskInfo, 0, 512);</a>
<a name="ln264">	memset(Directory, 0, 4096);</a>
<a name="ln265">	memcpy(DiskInfo, fs_tag, 4);				// Add the 'BMFS' tag</a>
<a name="ln266">	fseek(disk, 1024, SEEK_SET);				// Seek 1KiB in for disk information</a>
<a name="ln267">	fwrite(DiskInfo, 512, 1, disk);			// Write 512 bytes for the DiskInfo</a>
<a name="ln268">	fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln269">	fwrite(Directory, 4096, 1, disk);		// Write 4096 bytes for the Directory</a>
<a name="ln270">	printf(&quot;Format complete.\n&quot;);</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273"> </a>
<a name="ln274">int initialize(char *diskname, char *size, char *mbr, char *boot, char *kernel)</a>
<a name="ln275">{</a>
<a name="ln276">	unsigned long long diskSize = 0;</a>
<a name="ln277">	unsigned long long writeSize = 0;</a>
<a name="ln278">	const char *bootFileType = NULL;</a>
<a name="ln279">	size_t bufferSize = 50 * 1024;</a>
<a name="ln280">	char * buffer = NULL;</a>
<a name="ln281">	FILE *mbrFile = NULL;</a>
<a name="ln282">	FILE *bootFile = NULL;</a>
<a name="ln283">	FILE *kernelFile = NULL;</a>
<a name="ln284">	int diskSizeFactor = 0;</a>
<a name="ln285">	size_t chunkSize = 0;</a>
<a name="ln286">	int ret = 0;</a>
<a name="ln287">	size_t i;</a>
<a name="ln288"> </a>
<a name="ln289">	// Determine how the second file will be described in output messages.</a>
<a name="ln290">	// If a kernel file is specified too, then assume the second file is the</a>
<a name="ln291">	// boot loader.  If no kernel file is specified, assume the boot loader</a>
<a name="ln292">	// and kernel are combined into one system file.</a>
<a name="ln293">	if (boot != NULL)</a>
<a name="ln294">	{</a>
<a name="ln295">		bootFileType = &quot;boot loader&quot;;</a>
<a name="ln296">		if (kernel == NULL)</a>
<a name="ln297">		{</a>
<a name="ln298">			bootFileType = &quot;system&quot;;</a>
<a name="ln299">		}</a>
<a name="ln300">	}</a>
<a name="ln301"> </a>
<a name="ln302">	// Validate the disk size string and convert it to an integer value.</a>
<a name="ln303">	for (i = 0; size[i] != '\0' &amp;&amp; ret == 0; ++i)</a>
<a name="ln304">	{</a>
<a name="ln305">		char ch = size[i];</a>
<a name="ln306">		if (isdigit(ch))</a>
<a name="ln307">		{</a>
<a name="ln308">			unsigned int n = ch - '0';</a>
<a name="ln309">			if (diskSize * 10 &gt; diskSize ) // Make sure we don't overflow</a>
<a name="ln310">			{</a>
<a name="ln311">				diskSize *= 10;</a>
<a name="ln312">				diskSize += n;</a>
<a name="ln313">			}</a>
<a name="ln314">			else if (diskSize == 0) // First loop iteration</a>
<a name="ln315">			{</a>
<a name="ln316">				diskSize += n;</a>
<a name="ln317">			}</a>
<a name="ln318">			else</a>
<a name="ln319">			{</a>
<a name="ln320">				printf(&quot;Error: Disk size is too large\n&quot;);</a>
<a name="ln321">				ret = 1;</a>
<a name="ln322">			}</a>
<a name="ln323">		}</a>
<a name="ln324">		else if (i == 0) // No digits specified</a>
<a name="ln325">		{</a>
<a name="ln326">			printf(&quot;Error: A numeric disk size must be specified\n&quot;);</a>
<a name="ln327">			ret = 1;</a>
<a name="ln328">		}</a>
<a name="ln329">		else</a>
<a name="ln330">		{</a>
<a name="ln331">			switch (toupper(ch))</a>
<a name="ln332">			{</a>
<a name="ln333">					case 'K':</a>
<a name="ln334">						diskSizeFactor = 1;</a>
<a name="ln335">						break;</a>
<a name="ln336">					case 'M':</a>
<a name="ln337">						diskSizeFactor = 2;</a>
<a name="ln338">						break;</a>
<a name="ln339">					case 'G':</a>
<a name="ln340">						diskSizeFactor = 3;</a>
<a name="ln341">						break;</a>
<a name="ln342">					case 'T':</a>
<a name="ln343">						diskSizeFactor = 4;</a>
<a name="ln344">						break;</a>
<a name="ln345">					case 'P':</a>
<a name="ln346">						diskSizeFactor = 5;</a>
<a name="ln347">						break;</a>
<a name="ln348">					default:</a>
<a name="ln349">						printf(&quot;Error: Invalid disk size string: '%s'\n&quot;, size);</a>
<a name="ln350">						ret = 1;</a>
<a name="ln351">						break;</a>
<a name="ln352">			}</a>
<a name="ln353"> </a>
<a name="ln354">			// If this character is a valid unit indicator, but is not at the</a>
<a name="ln355">			// end of the string, then the string is invalid.</a>
<a name="ln356">			if (ret == 0 &amp;&amp; size[i+1] != '\0')</a>
<a name="ln357">			{</a>
<a name="ln358">				printf(&quot;Error: Invalid disk size string: '%s'\n&quot;, size);</a>
<a name="ln359">				ret = 1;</a>
<a name="ln360">			}</a>
<a name="ln361">		}</a>
<a name="ln362">	}</a>
<a name="ln363"> </a>
<a name="ln364">	// Adjust the disk size if a unit indicator was given.  Note that an</a>
<a name="ln365">	// input of something like &quot;0&quot; or &quot;0K&quot; will get past the checks above.</a>
<a name="ln366">	if (ret == 0 &amp;&amp; diskSize &gt; 0 &amp;&amp; diskSizeFactor &gt; 0)</a>
<a name="ln367">	{</a>
<a name="ln368">		while (diskSizeFactor--)</a>
<a name="ln369">		{</a>
<a name="ln370">			if (diskSize * 1024 &gt; diskSize ) // Make sure we don't overflow</a>
<a name="ln371">			{</a>
<a name="ln372">				diskSize *= 1024;</a>
<a name="ln373">			}</a>
<a name="ln374">			else</a>
<a name="ln375">			{</a>
<a name="ln376">				printf(&quot;Error: Disk size is too large\n&quot;);</a>
<a name="ln377">				ret = 1;</a>
<a name="ln378">			}</a>
<a name="ln379">		}</a>
<a name="ln380">	}</a>
<a name="ln381"> </a>
<a name="ln382">	// Make sure the disk size is large enough.</a>
<a name="ln383">	if (ret == 0)</a>
<a name="ln384">	{</a>
<a name="ln385">		if (diskSize &lt; minimumDiskSize)</a>
<a name="ln386">		{</a>
<a name="ln387">			printf( &quot;Error: Disk size must be at least %llu bytes (%lluMiB)\n&quot;, minimumDiskSize, minimumDiskSize / (1024*1024));</a>
<a name="ln388">			ret = 1;</a>
<a name="ln389">		}</a>
<a name="ln390">	}</a>
<a name="ln391"> </a>
<a name="ln392">	// Open the Master boot Record file for reading.</a>
<a name="ln393">	if (ret == 0 &amp;&amp; mbr != NULL)</a>
<a name="ln394">	{</a>
<a name="ln395">		mbrFile = fopen(mbr, &quot;rb&quot;);</a>
<a name="ln396">		if (mbrFile == NULL )</a>
<a name="ln397">		{</a>
<a name="ln398">			printf(&quot;Error: Unable to open MBR file '%s'\n&quot;, mbr);</a>
<a name="ln399">			ret = 1;</a>
<a name="ln400">		}</a>
<a name="ln401">	}</a>
<a name="ln402"> </a>
<a name="ln403">	// Open the boot loader file for reading.</a>
<a name="ln404">	if (ret == 0 &amp;&amp; boot != NULL)</a>
<a name="ln405">	{</a>
<a name="ln406">		bootFile = fopen(boot, &quot;rb&quot;);</a>
<a name="ln407">		if (bootFile == NULL )</a>
<a name="ln408">		{</a>
<a name="ln409">			printf(&quot;Error: Unable to open %s file '%s'\n&quot;, bootFileType, boot);</a>
<a name="ln410">			ret = 1;</a>
<a name="ln411">		}</a>
<a name="ln412">	}</a>
<a name="ln413"> </a>
<a name="ln414">	// Open the kernel file for reading.</a>
<a name="ln415">	if (ret == 0 &amp;&amp; kernel != NULL)</a>
<a name="ln416">	{</a>
<a name="ln417">		kernelFile = fopen(kernel, &quot;rb&quot;);</a>
<a name="ln418">		if (kernelFile == NULL )</a>
<a name="ln419">		{</a>
<a name="ln420">			printf(&quot;Error: Unable to open kernel file '%s'\n&quot;, kernel);</a>
<a name="ln421">			ret = 1;</a>
<a name="ln422">		}</a>
<a name="ln423">	}</a>
<a name="ln424"> </a>
<a name="ln425">	// Allocate buffer to use for filling the disk image with zeros.</a>
<a name="ln426">	if (ret == 0)</a>
<a name="ln427">	{</a>
<a name="ln428">		buffer = (char *) malloc(bufferSize);</a>
<a name="ln429">		if (buffer == NULL)</a>
<a name="ln430">		{</a>
<a name="ln431">			printf(&quot;Error: Failed to allocate buffer\n&quot;);</a>
<a name="ln432">			ret = 1;</a>
<a name="ln433">		}</a>
<a name="ln434">	}</a>
<a name="ln435"> </a>
<a name="ln436">	// Open the disk image file for writing.  This will truncate the disk file</a>
<a name="ln437">	// if it already exists, so we should do this only after we're ready to</a>
<a name="ln438">	// actually write to the file.</a>
<a name="ln439">	if (ret == 0)</a>
<a name="ln440">	{</a>
<a name="ln441">		disk = fopen(diskname, &quot;wb&quot;);</a>
<a name="ln442">		if (disk == NULL)</a>
<a name="ln443">		{</a>
<a name="ln444">			printf(&quot;Error: Unable to open disk '%s'\n&quot;, diskname);</a>
<a name="ln445">			ret = 1;</a>
<a name="ln446">		}</a>
<a name="ln447">	}</a>
<a name="ln448"> </a>
<a name="ln449">	// Fill the disk image with zeros.</a>
<a name="ln450">	if (ret == 0)</a>
<a name="ln451">	{</a>
<a name="ln452">		double percent;</a>
<a name="ln453">		memset(buffer, 0, bufferSize);</a>
<a name="ln454">		writeSize = 0;</a>
<a name="ln455">		while (writeSize &lt; diskSize)</a>
<a name="ln456">		{</a>
<a name="ln457">			percent = writeSize;</a>
<a name="ln458">			percent /= diskSize;</a>
<a name="ln459">			percent *= 100;</a>
<a name="ln460">			printf(&quot;Formatting disk: %llu of %llu bytes (%.0f%%)...\r&quot;, writeSize, diskSize, percent);</a>
<a name="ln461">			chunkSize = bufferSize;</a>
<a name="ln462">			if (chunkSize &gt; diskSize - writeSize)</a>
<a name="ln463">			{</a>
<a name="ln464">				chunkSize = diskSize - writeSize;</a>
<a name="ln465">			}</a>
<a name="ln466">			if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln467">			{</a>
<a name="ln468">				printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln469">				ret = 1;</a>
<a name="ln470">				break;</a>
<a name="ln471">			}</a>
<a name="ln472">			writeSize += chunkSize;</a>
<a name="ln473">		}</a>
<a name="ln474">		if (ret == 0)</a>
<a name="ln475">		{</a>
<a name="ln476">			printf(&quot;Formatting disk: %llu of %llu bytes (100%%)%9s\n&quot;, writeSize, diskSize, &quot;&quot;);</a>
<a name="ln477">		}</a>
<a name="ln478">	}</a>
<a name="ln479"> </a>
<a name="ln480">	// Format the disk.</a>
<a name="ln481">	if (ret == 0)</a>
<a name="ln482">	{</a>
<a name="ln483">		rewind(disk);</a>
<a name="ln484">		format();</a>
<a name="ln485">	}</a>
<a name="ln486"> </a>
<a name="ln487">	// Write the master boot record if it was specified by the caller.</a>
<a name="ln488">	if (ret == 0 &amp;&amp; mbrFile !=NULL)</a>
<a name="ln489">	{</a>
<a name="ln490">		printf(&quot;Writing master boot record.\n&quot;);</a>
<a name="ln491">		fseek(disk, 0, SEEK_SET);</a>
<a name="ln492">		if (fread(buffer, 512, 1, mbrFile) == 1)</a>
<a name="ln493">		{</a>
<a name="ln494">			if (fwrite(buffer, 512, 1, disk) != 1)</a>
<a name="ln495">			{</a>
<a name="ln496">				printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln497">				ret = 1;</a>
<a name="ln498">			}</a>
<a name="ln499">		}</a>
<a name="ln500">		else</a>
<a name="ln501">		{</a>
<a name="ln502">			printf(&quot;Error: Failed to read file '%s'\n&quot;, mbr);</a>
<a name="ln503">			ret = 1;</a>
<a name="ln504">		}</a>
<a name="ln505">	}</a>
<a name="ln506"> </a>
<a name="ln507">	// Write the boot loader if it was specified by the caller.</a>
<a name="ln508">	if (ret == 0 &amp;&amp; bootFile !=NULL)</a>
<a name="ln509">	{</a>
<a name="ln510">		printf(&quot;Writing %s file.\n&quot;, bootFileType);</a>
<a name="ln511">		fseek(disk, 8192, SEEK_SET);</a>
<a name="ln512">		for (;;)</a>
<a name="ln513">		{</a>
<a name="ln514">			chunkSize = fread( buffer, 1, bufferSize, bootFile);</a>
<a name="ln515">			if (chunkSize &gt; 0)</a>
<a name="ln516">			{</a>
<a name="ln517">				if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln518">				{</a>
<a name="ln519">					printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln520">					ret = 1;</a>
<a name="ln521">				}</a>
<a name="ln522">			}</a>
<a name="ln523">			else</a>
<a name="ln524">			{</a>
<a name="ln525">				if (ferror(disk))</a>
<a name="ln526">				{</a>
<a name="ln527">					printf(&quot;Error: Failed to read file '%s'\n&quot;, boot);</a>
<a name="ln528">					ret = 1;</a>
<a name="ln529">				}</a>
<a name="ln530">				break;</a>
<a name="ln531">			}</a>
<a name="ln532">		}</a>
<a name="ln533">	}</a>
<a name="ln534"> </a>
<a name="ln535">	// Write the kernel if it was specified by the caller. The kernel must</a>
<a name="ln536">	// immediately follow the boot loader on disk (i.e. no seek needed.)</a>
<a name="ln537">	if (ret == 0 &amp;&amp; kernelFile !=NULL)</a>
<a name="ln538">	{</a>
<a name="ln539">		printf(&quot;Writing kernel.\n&quot;);</a>
<a name="ln540">		for (;;)</a>
<a name="ln541">		{</a>
<a name="ln542">			chunkSize = fread( buffer, 1, bufferSize, kernelFile);</a>
<a name="ln543">			if (chunkSize &gt; 0)</a>
<a name="ln544">			{</a>
<a name="ln545">				if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln546">				{</a>
<a name="ln547">					printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln548">					ret = 1;</a>
<a name="ln549">				}</a>
<a name="ln550">			}</a>
<a name="ln551">			else</a>
<a name="ln552">			{</a>
<a name="ln553">				if (ferror(disk))</a>
<a name="ln554">				{</a>
<a name="ln555">					printf(&quot;Error: Failed to read file '%s'\n&quot;, kernel);</a>
<a name="ln556">					ret = 1;</a>
<a name="ln557">				}</a>
<a name="ln558">				break;</a>
<a name="ln559">			}</a>
<a name="ln560">		}</a>
<a name="ln561">	}</a>
<a name="ln562"> </a>
<a name="ln563">	// Close any files that were opened.</a>
<a name="ln564">	if (mbrFile != NULL)</a>
<a name="ln565">	{</a>
<a name="ln566">		fclose(mbrFile);</a>
<a name="ln567">	}</a>
<a name="ln568">	if (bootFile != NULL)</a>
<a name="ln569">	{</a>
<a name="ln570">		fclose(bootFile);</a>
<a name="ln571">	}</a>
<a name="ln572">	if (kernelFile != NULL)</a>
<a name="ln573">	{</a>
<a name="ln574">		fclose(kernelFile);</a>
<a name="ln575">	}</a>
<a name="ln576">	if (disk != NULL)</a>
<a name="ln577">	{</a>
<a name="ln578">		fclose(disk);</a>
<a name="ln579">		disk = NULL;</a>
<a name="ln580">	}</a>
<a name="ln581"> </a>
<a name="ln582">	// Free the buffer if it was allocated.</a>
<a name="ln583">	if (buffer != NULL)</a>
<a name="ln584">	{</a>
<a name="ln585">		free(buffer);</a>
<a name="ln586">	}</a>
<a name="ln587"> </a>
<a name="ln588">	if (ret == 0)</a>
<a name="ln589">	{</a>
<a name="ln590">		printf(&quot;Disk initialization complete.\n&quot;);</a>
<a name="ln591">	}</a>
<a name="ln592"> </a>
<a name="ln593">	return ret;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596"> </a>
<a name="ln597">// helper function for qsort, sorts by StartingBlock field</a>
<a name="ln598">static int StartingBlockCmp(const void *pa, const void *pb)</a>
<a name="ln599">{</a>
<a name="ln600">	struct BMFSEntry *ea = (struct BMFSEntry *)pa;</a>
<a name="ln601">	struct BMFSEntry *eb = (struct BMFSEntry *)pb;</a>
<a name="ln602">	// empty records go to the end</a>
<a name="ln603">	if (ea-&gt;FileName[0] == 0x01)</a>
<a name="ln604">		return 1;</a>
<a name="ln605">	if (eb-&gt;FileName[0] == 0x01)</a>
<a name="ln606">		return -1;</a>
<a name="ln607">	// compare non-empty records by their starting blocks number</a>
<a name="ln608">	return (ea-&gt;StartingBlock - eb-&gt;StartingBlock);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">void create(char *filename, unsigned long long maxsize)</a>
<a name="ln612">{</a>
<a name="ln613">	struct BMFSEntry tempentry;</a>
<a name="ln614">	int slot;</a>
<a name="ln615">	</a>
<a name="ln616">	if (maxsize % 2 != 0)</a>
<a name="ln617">		maxsize++;</a>
<a name="ln618"> </a>
<a name="ln619">	if (findfile(filename, &amp;tempentry, &amp;slot) == 0)</a>
<a name="ln620">	{</a>
<a name="ln621">		unsigned long long blocks_requested = maxsize / 2; // how many blocks to allocate</a>
<a name="ln622">		unsigned long long num_blocks = disksize / 2; // number of blocks in the disk</a>
<a name="ln623">		char dir_copy[4096]; // copy of directory</a>
<a name="ln624">		int num_used_entries = 0; // how many entries of Directory are either used or deleted</a>
<a name="ln625">		int first_free_entry = -1; // where to put new entry</a>
<a name="ln626">		int tint;</a>
<a name="ln627">		struct BMFSEntry *pEntry;</a>
<a name="ln628">		unsigned long long new_file_start = 0;</a>
<a name="ln629">		unsigned long long prev_file_end = 1;</a>
<a name="ln630"> </a>
<a name="ln631">		printf(&quot;Creating new file...\n&quot;);</a>
<a name="ln632"> </a>
<a name="ln633">		// Make a copy of Directory to play with</a>
<a name="ln634">		memcpy(dir_copy, Directory, 4096);</a>
<a name="ln635"> </a>
<a name="ln636">		// Calculate number of files</a>
<a name="ln637">		for (tint = 0; tint &lt; 64; tint++) </a>
<a name="ln638">		{</a>
<a name="ln639">			pEntry = (struct BMFSEntry *)(dir_copy + tint * 64); // points to the current directory entry</a>
<a name="ln640">			if (pEntry-&gt;FileName[0] == 0x00) // end of directory</a>
<a name="ln641">			{</a>
<a name="ln642">				num_used_entries = tint;</a>
<a name="ln643">				if (first_free_entry == -1)</a>
<a name="ln644">					first_free_entry = tint; // there were no unused entires before, will use this one</a>
<a name="ln645">				break;</a>
<a name="ln646">			}</a>
<a name="ln647">			else if (pEntry-&gt;FileName[0] == 0x01) // unused entry</a>
<a name="ln648">			{</a>
<a name="ln649">				if (first_free_entry == -1)</a>
<a name="ln650">					first_free_entry = tint; // will use it for our new file</a>
<a name="ln651">			}</a>
<a name="ln652">		}</a>
<a name="ln653"> </a>
<a name="ln654">		if (first_free_entry == -1)</a>
<a name="ln655">		{</a>
<a name="ln656">			printf(&quot;Cannot create file: no free directory entries.\n&quot;);</a>
<a name="ln657">			return;</a>
<a name="ln658">		}</a>
<a name="ln659"> </a>
<a name="ln660">		// Find an area with enough free blocks</a>
<a name="ln661">		// Sort our copy of the directory by starting block number</a>
<a name="ln662">		qsort(dir_copy, num_used_entries, 64, StartingBlockCmp);</a>
<a name="ln663"> </a>
<a name="ln664">		for (tint = 0; tint &lt; num_used_entries + 1; tint++)</a>
<a name="ln665">		{</a>
<a name="ln666">			// on each iteration of this loop we'll see if a new file can fit</a>
<a name="ln667">			// between the end of the previous file (initially == 1) </a>
<a name="ln668">			// and the beginning of the current file (or the last data block if there are no more files).</a>
<a name="ln669"> </a>
<a name="ln670">			unsigned long long this_file_start;</a>
<a name="ln671">			pEntry = (struct BMFSEntry *)(dir_copy + tint * 64); // points to the current directory entry</a>
<a name="ln672"> </a>
<a name="ln673">			if (tint == num_used_entries || pEntry-&gt;FileName[0] == 0x01) </a>
<a name="ln674">				this_file_start = num_blocks - 1; // index of the last block</a>
<a name="ln675">			else</a>
<a name="ln676">				this_file_start = pEntry-&gt;StartingBlock;</a>
<a name="ln677"> </a>
<a name="ln678">			if (this_file_start - prev_file_end &gt;= blocks_requested) </a>
<a name="ln679">			{ // fits here</a>
<a name="ln680">				new_file_start = prev_file_end;</a>
<a name="ln681">				break;</a>
<a name="ln682">			}</a>
<a name="ln683"> </a>
<a name="ln684">			if (tint &lt; num_used_entries)</a>
<a name="ln685">				prev_file_end = pEntry-&gt;StartingBlock + pEntry-&gt;ReservedBlocks;</a>
<a name="ln686">		}</a>
<a name="ln687"> </a>
<a name="ln688">		if (new_file_start == 0) </a>
<a name="ln689">		{</a>
<a name="ln690">			printf(&quot;Cannot create file of size %lld MiB.\n&quot;, maxsize);</a>
<a name="ln691">			return;</a>
<a name="ln692">		}</a>
<a name="ln693"> </a>
<a name="ln694">		// Add file record to Directory</a>
<a name="ln695">		pEntry = (struct BMFSEntry *)(Directory + first_free_entry * 64);</a>
<a name="ln696">		pEntry-&gt;StartingBlock = new_file_start;</a>
<a name="ln697">		pEntry-&gt;ReservedBlocks = blocks_requested;</a>
<a name="ln698">		pEntry-&gt;FileSize = 0;</a>
<a name="ln699">		strcpy(pEntry-&gt;FileName, filename);</a>
<a name="ln700"> </a>
<a name="ln701">		if (first_free_entry == num_used_entries &amp;&amp; num_used_entries + 1 &lt; 64)</a>
<a name="ln702">		{</a>
<a name="ln703">			// here we used the record that was marked with 0x00, </a>
<a name="ln704">			// so make sure to mark the next record with 0x00 if it exists</a>
<a name="ln705">			pEntry = (struct BMFSEntry *)(Directory + (num_used_entries + 1) * 64);</a>
<a name="ln706">			pEntry-&gt;FileName[0] = 0x00;</a>
<a name="ln707">		}</a>
<a name="ln708"> </a>
<a name="ln709">		// Flush Directory to disk</a>
<a name="ln710">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln711">		fwrite(Directory, 4096, 1, disk);			// Write 4096 bytes for the Directory</a>
<a name="ln712"> </a>
<a name="ln713">//		printf(&quot;Complete: file %s starts at block %lld, directory entry #%d.\n&quot;, filename, new_file_start, first_free_entry);</a>
<a name="ln714">		printf(&quot;Complete\n&quot;);</a>
<a name="ln715">	}</a>
<a name="ln716">	else</a>
<a name="ln717">	{</a>
<a name="ln718">		printf(&quot;Error: File already exists.\n&quot;);</a>
<a name="ln719">	}</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722"> </a>
<a name="ln723">void read(char *filename)</a>
<a name="ln724">{</a>
<a name="ln725">	struct BMFSEntry tempentry;</a>
<a name="ln726">	FILE *tfile;</a>
<a name="ln727">	int tint, slot;</a>
<a name="ln728"> </a>
<a name="ln729">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln730">	{</a>
<a name="ln731">		printf(&quot;Error: File not found in BMFS.\n&quot;);</a>
<a name="ln732">	}</a>
<a name="ln733">	else</a>
<a name="ln734">	{</a>
<a name="ln735">		printf(&quot;Reading '%s' from BMFS to local file... &quot;, filename);</a>
<a name="ln736">		if ((tfile = fopen(tempentry.FileName, &quot;wb&quot;)) == NULL)</a>
<a name="ln737">		{</a>
<a name="ln738">			printf(&quot;Error: Could not open local file '%s'\n&quot;, tempentry.FileName);</a>
<a name="ln739">		}</a>
<a name="ln740">		else</a>
<a name="ln741">		{</a>
<a name="ln742">			fseek(disk, tempentry.StartingBlock*2097152, SEEK_SET); // Skip to the starting block in the disk</a>
<a name="ln743">			for (tint=0; tint&lt;tempentry.FileSize; tint++)</a>
<a name="ln744">			{</a>
<a name="ln745">				putc(getc(disk), tfile);			// This is really terrible.</a>
<a name="ln746">				// TODO: Rework with fread and fwrite (ideally with a 2MiB buffer)</a>
<a name="ln747">			}</a>
<a name="ln748">			fclose(tfile);</a>
<a name="ln749">			printf(&quot;Complete\n&quot;);</a>
<a name="ln750">		}</a>
<a name="ln751">	}</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">void write(char *filename)</a>
<a name="ln756">{</a>
<a name="ln757">	struct BMFSEntry tempentry;</a>
<a name="ln758">	FILE *tfile;</a>
<a name="ln759">	int tint, slot;</a>
<a name="ln760">	unsigned long long tempfilesize;</a>
<a name="ln761"> </a>
<a name="ln762">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln763">	{</a>
<a name="ln764">		printf(&quot;Error: File not found in BMFS. A file entry must first be created.\n&quot;);</a>
<a name="ln765">	}</a>
<a name="ln766">	else</a>
<a name="ln767">	{</a>
<a name="ln768">		printf(&quot;Writing local file '%s' to BMFS... &quot;, filename);</a>
<a name="ln769">		if ((tfile = fopen(filename, &quot;rb&quot;)) == NULL)</a>
<a name="ln770">		{</a>
<a name="ln771">			printf(&quot;Error: Could not open local file '%s'\n&quot;, tempentry.FileName);</a>
<a name="ln772">		}</a>
<a name="ln773">		else</a>
<a name="ln774">		{</a>
<a name="ln775">			// Is there enough room in BMFS?</a>
<a name="ln776">			fseek(tfile, 0, SEEK_END);</a>
<a name="ln777">			tempfilesize = ftell(tfile);</a>
<a name="ln778">			rewind(tfile);</a>
<a name="ln779">			if ((tempentry.ReservedBlocks*2097152) &lt; tempfilesize)</a>
<a name="ln780">			{</a>
<a name="ln781">				printf(&quot;Not enough reserved space in BMFS.\n&quot;);</a>
<a name="ln782">			}</a>
<a name="ln783">			else</a>
<a name="ln784">			{</a>
<a name="ln785">				fseek(disk, tempentry.StartingBlock*2097152, SEEK_SET); // Skip to the starting block in the disk</a>
<a name="ln786">				for (tint=0; tint&lt;tempfilesize; tint++)</a>
<a name="ln787">				{</a>
<a name="ln788">					putc(getc(tfile), disk);			// This is really terrible.</a>
<a name="ln789">					// TODO: Rework with fread and fwrite (ideally with a 2MiB buffer)</a>
<a name="ln790">				}</a>
<a name="ln791">				// Update directory</a>
<a name="ln792">				memcpy(Directory+(slot*64)+48, &amp;tempfilesize, 8);</a>
<a name="ln793">				fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln794">				fwrite(Directory, 4096, 1, disk);			// Write new directory to disk</a>
<a name="ln795">				printf(&quot;Complete\n&quot;);</a>
<a name="ln796">			}</a>
<a name="ln797">			fclose(tfile);</a>
<a name="ln798">		}</a>
<a name="ln799">	}</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802"> </a>
<a name="ln803">void delete(char *filename)</a>
<a name="ln804">{</a>
<a name="ln805">	struct BMFSEntry tempentry;</a>
<a name="ln806">	char delmarker = 0x01;</a>
<a name="ln807">	int slot;</a>
<a name="ln808"> </a>
<a name="ln809">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln810">	{</a>
<a name="ln811">		printf(&quot;Error: File not found in BMFS.\n&quot;);</a>
<a name="ln812">	}</a>
<a name="ln813">	else</a>
<a name="ln814">	{</a>
<a name="ln815">		printf(&quot;Deleting file '%s' from BMFS... &quot;, filename);</a>
<a name="ln816">		// Update directory</a>
<a name="ln817">		memcpy(Directory+(slot*64), &amp;delmarker, 1);</a>
<a name="ln818">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln819">		fwrite(Directory, 4096, 1, disk);			// Write new directory to disk				</a>
<a name="ln820">		printf(&quot;Complete\n&quot;);</a>
<a name="ln821">	}</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824"> </a>
<a name="ln825">/* EOF */</a>
</code></pre>
<div class="balloon" rel="553"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'disk' pointer was utilized before it was verified against nullptr. Check lines: 553, 576.</p></div>
<div class="balloon" rel="639"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'dir_copy' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="695"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'Directory' is cast to a more strictly aligned pointer type.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>